<?xml version="1.0"?>
<!DOCTYPE QR SYSTEM "QuickReview.dtd">

<QuestionsAndAnswers>

<QA ID="1" type="OneAnswer" category="CPP" countdown="0" resetto="0" >

  <Question>
        How can I handle a constructor that fails ?
  </Question>

  <Answer>
     By throwing an exception. Constructors don't have a return type, so it's not possible to use
     return codes. The best way to signal constructor failure is therefore to throw an exception.
  </Answer>
</QA>


<QA ID="2" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is difference between process and thread ?
  </Question>
  <Answer>
     The typical difference is that threads (of the same process) run in a shared memory space, 
     while processes run in separate memory spaces.
     Each thread has its own storage, stack, environment block, security context, set of registers
     exception handlers, priority. But all threads in one process share the same heap.
  </Answer>
</QA>
<QA ID="3" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      Difference between Lock and control variable ?
  </Question>
  <Answer>
        ??
  </Answer>
</QA>
<QA ID="4" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      Difference between mutex and semorephone ?
  </Question>
  <Answer>
    - A mutex can be owned by only one thread at a time, enabling threads to coordinate mutually 
      exclusive access to a shared resource.

    - A semaphore maintains a count between zero and some maximum value, limiting the number of 
      threads that are simultaneously accessing a shared resource.
  </Answer>
</QA>
<QA ID="5" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is Unique pointer and what is the diffrence between unique pointer and shared pointer?
  </Question>
  <Answer>
    - Unique pointer and Shared pointer are all smart pointers. Unique pointer means an object 
      can only be pointered by one pointer

    - shared pointers keeps a count on number of pointers to an object and when the count drops 
      to 0, the object is destroyed !
  </Answer>
</QA>
<QA ID="6" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is weak pointer?
  </Question>
  <Answer>
      Weak pointer is a kind of pointer that does not own the object, does not affect the pointer count!
  </Answer>
</QA>
<QA ID="7" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is vector?
  </Question>
  <Answer>
    A vector is a dynamic array that can only grow in one direction, and is contiguously allocated 
    in memory.

   vector pros and cons:
   - fast insert/remove at the end: O(1)
   - slow insert/remove at the begining and middle: O(n)
   - slow search (linear time): O(n)
   - random access
  </Answer>
</QA>

<QA ID="8" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is deque ?
  </Question>
  <Answer>
      A deque is a dynamic array that can grow in both directions, it is an indexed sequence container 
      that allows fast insertion and deletion at both its beginning and its end. In addition, insertion 
      and deletion at either end of a deque never invalidates pointers or references to the rest of 
      the elements. As opposed to std::vector, the elements of a deque are not stored contiguously: 
      typical implementations use a sequence of individually allocated fixed-size arrays, with additional 
      bookkeeping, which means indexed access to deque must perform two pointer dereferences, compared 
      to vector's indexed access which performs only one.

      The storage of a deque is automatically expanded and contracted as needed. Expansion of a deque is 
      cheaper than a std::vector because it does not involve copying of the existing elements to a new 
      memory location. On the other hand, deques typically have large minimal memory cost; a deque 
      holding just one element has to allocate its full internal array (e.g. 8 times the object size on 
      64-bit libstdc++; 16 times the object size or 4096 bytes, whichever is larger, on 64-bit libc++).

      The complexity (efficiency) of common operations on deques is as follows:

      1. Fast Random access - constant O(1)
      2. Fast Insertion or removal of elements at the end or beginning - constant O(1)
      3. Slow Insertion or removal of elements - linear O(n)
  </Answer>
</QA>

<QA ID="9" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is array and what is its pros and cons ?
  </Question>
  <Answer>
      array is fixed in size! and different size makes them different types.
  </Answer>
</QA>
<QA ID="10" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is the difference between list and forward list ?
  </Question>
  <Answer>
      list is a doubly-linked list. Forward list is a singly-linked list
  </Answer>
</QA>
<QA ID="11" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is RAII ??
  </Question>
  <Answer>
      It is Resource Acquisition is initialization.
         In RAII, holding a resource is tied to object lifetime: resource allocation
      (or acquisition) is done during object creation by the constructor, 
      while resource deallocation (release) is done during object destruction
      by the destructor.
  </Answer>
</QA>
<QA ID="12" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What are STL Containers
  </Question>
  <Answer>
   STL Containers can be divieded into 3 categories:
   1) Sequence Containers (Array and linked list)
       - vector
       - deque
       - list
       - forward list
       - array
   2) Associative Containers (binary tree)
       - set, multiset,
       - map, multimap
   3) Unordered Containers (hash table)
       - Unordered set/multiset;
       - Unordered map/multimap

   its headers to include: 
        - &lt;vector&gt;
        - &lt;deque&gt;
        - &lt;list&gt;
        - &lt;set&gt;
        - &lt;map&gt;
        - &lt;unordered_set&gt;
        - &lt;unordered_map&gt;

   other STL includes:
        - &lt;iterator&gt;
        - &lt;algorithm&gt;
        - &lt;numeric&gt;     
        - &lt;functional&gt;  //for functors

   methods shared across all containers:
   - empty()   //check for empty
   - size()
   - clear()   //remove all elements
   - swap(T)   //swap all elements
  </Answer>
</QA>
<QA ID="13" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is associate containers ?
  </Question>
  <Answer>
      Associate containers refer to map/multimap and set/multiset.
      Associate means keys are associated with values
      For set/multiset, the keys can be considered the same as values
      - They are always sorted, so no push_front(), push_back() methods
      - They are implemented as binary tree.
      - They are fast in search
      - They are slow in traversing
      - No Random acces, no [] operator
      - Elements (keys) can't be modified
  </Answer>
</QA>
<QA ID="14" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      show some set snippets:
  </Question>
  <Answer>

  snippet:

    set&lt;int&gt; myset;
    myset.insert(3);
    myset.insert(1);
    myset.insert(7);         //myset: {1,3,7}

    set&lt;int&gt;::iterator it;
    it=myset.find(7);       //fast, sequence containers do not have find() memeber function
                            //fast O(log(n))   &lt;=====outstanding feature
    pair&lt;set&lt;int&gt;::iterator, bool&gt; ret;
    ret=myset.insert(3);    //no new element inserted, because no duplicates allowed
    if(ret.second==false)   //return a pair of values: ret.first, ret.second
      it=ret.first;         //"it" now points to element 3
     
    myset.insert(it,9);     //hint where it is pointing to, {1,3,7,9}
    myset.erase(it);        //myset: {1,7,9}
    myset.erase(7);         //myset: {1,9}
   
  </Answer>
</QA>
<QA ID="15" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      what is difference between set and muti set ?
  </Question>
  <Answer>
      Difference is that multi set allows duplcates while set does not allow duplicates
      Difference between map and multimap is multimap allows duplicate keys
  </Answer>
</QA>
<QA ID="16" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is the difference between set/multiset and map/multimap ?
  </Question>
  <Answer>
      Map/multimap is just a key-value paired version of set/multiset.
  </Answer>
</QA>
<QA ID="17" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What about unordered containers ? what are unordered containers and what are their pros and cons
  </Question>
  <Answer>
      Unordered set/multiset, map/multimap are unordered containers
      they are implemented as hash tables 
      has following features:
        -fast search O(1)
        -fast insert O(1)
        -element value can't be changed for unordered set/multiset
        -element key can't be change for unordered map/multimap

      snippet:
        unordered_set&lt;string&gt; myset= { "red", "green", "blue" };
        unordered_set&lt;string&gt;::const_iterator itr =  myset.find("green");  //fast, O(1)
        if(itr != myset.end())   //need to check if found
          cout &lt;&lt; *itr &lt;&lt; endl;
        myset.insert("yellow");   // O(1), fast

        vector&lt;string&gt; vec={"purple","pink"};    //an vector to be inserted into myset
        myset.insert(vec.begin(), vec.end());    //insert a vector into a set 

        //Hash table APIs: load_factor(),bucket(),bucket_count()
        cout &lt;&lt; "load_factor="&lt;&lt; myset.load_factor() &lt;&lt; endl;
        string x = "red";
        cout &lt;&lt; x &lt;&lt; " is in buket #" &lt;&lt; myset.bucket(x) &lt;&lt; endl;
        cout &lt;&lt; "Total bucket #=" &lt;&lt; myset.bucket_count() &lt;&lt; endl;

  </Answer>
</QA>
<QA ID="18" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is Associate Array?
  </Question>
  <Answer>
      Associate Array is map and unordered map. They are Associate Containers with [] operators.
      
      Following snippet shows its usages:
       
      unordered_map&lt;char, string&gt; day={{'S',"Sunday"},{'M',"Monday"}};

      cout &lt;&lt; day['S']    &lt;&lt; endl;    //No  range check
      cout &lt;&lt; day.at('S') &lt;&lt; endl;    //Has range check

      vector&lt;int&gt; vec={1,2,3};
      vec[5]=5;                             // compile Error: out of range

      day['W'] = "Wednesday";               //OK, inserting {'W',"Wednesday'}
      day.insert(make_pair('F',"FRIDAY"));  //inserting, same as above

      day.insert(make_pair('M',"MONDAY));   //Already exist for M, failed
      day['M'] = "MONDAY";                  //Succeeded modifying: [] operator has write access

      //Effect of [] operator's write access:
      void foo (const unordered_map&lt;char, string&gt; &#38; m ) { //param m is const reference
         m['S'] = "SUNDAY";                  //compile error, write access
         cout &lt;&lt; m['S'] &lt;&lt; endl;            //compile error too for print access, which is write access writing this way
         auto itr = m.find('S');
         if(itr !=m.end())
           cout &lt;&lt; itr-&gt;second &lt;&lt;endl;       //compile OK, no write access !
      }

      foo(day);

      //so, use map or unordered map ? here are the factors to consider:
      // Associate array: map and unordered_map only:
      1 search O(1): unordered_map =&gt; may degrade to O(n)
          O(log(n)): map =&gt; garanteed O(log(n)) search time
      2 Can't use multimap and unordered_multimap:
          they do not have [] operator, so can't be used as an array
  </Answer>
</QA>

<QA ID="19" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is Container Adapter ?
  </Question>
  <Answer>
      Container Adapter provide restricted interface to underlying containers to meet special needs
      they are implemetned with fundamental container classes. There are 3:
      1. queue: FIFO:   push(), pop(), front(), back()
      2. stack: LIFO:   push(), Pop(), top()
      3. priority queue:push(), pop(), top(). First item always has the greatest priority
                 
      
  </Answer>
</QA>

<QA ID="20" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What are the 5 kinds of the iterators ?
  </Question>
  <Answer>
      1: Ramdom access iterators: vector, deque, array
      2: Bidirectional Iterators: list, set/multiset, map/multimap
      3: Forward Iterators: forward_list
      4: Input Iterator: int x = *itr; //can only move forward
      5: Output Iterator: *itr=100;    //can only move forward 

      Every container has a iterator and a const_iterator (Snippet):
      set&lt;int&gt;::iterator itr;           //RW access to container elements
      set&lt;int&gt;::const_interator citr;   //readonly access to container elements

      set&lt;int&gt; myset = {1,4,5,2,9};
      for(citr=myset.begin();citr!=myset.end();++citr){
        cout &lt;&lt; *citr &lt;&lt; endl;
        //*citr=3;   //error, citr has readonly access
      }

      for_each(myset.cbegin();myset.cend(),myfunction);   //C++11

      //iterator functions:
      advance(itr,5);          //Move itr forward by 5: itr += 5;
      distance(itr1,itr2);     //measure the distance between itr1 and itr2
  </Answer>
</QA>

<QA ID="21" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
    What is Iterator Adapter ?
  </Question>
  <Answer>
    Iterator adapters are predefined iterators, they are more powerful:

      1. Insert iterator (back_insert_iterator,front_insert_iterator)
      2. Stream iterator
      3. Reverse iterator
      4. Move iterator (c++11)

    Snippet:
      1. Insert iterator:

      vector&lt;int&gt; vec1 = {4,5};
      vector&lt;int&gt; vec2 = {13,14,16,18};
      vector&lt;int&gt;::iterator it = find(vec2.begin(),vec2.end(),16);
      insert_iterator&lt;vector&lt;int&gt;&gt; i_itr(vec2,it);
      copy(vec1.begin(),vec1,end(),i_itr);   //vec2: {12,14,4,5,16,18}
      // Other insert iterators: back-insert_iterator, front_insert_iterator

      2. Stream iterator: iterat through the data to and from a string:
         vector&lt;string&gt; vec4;
         copy(istream_iterator&lt;string&gt;(cin), istream_iterator&lt;string&gt;(),     //copy source range
             back_inserter(vec4));                                           //copy dest, insert everything into vec4 from input stream
         copy(vec4.begin(),vec4.end(),ostream_iterator&lt;string&gt;(cout, " "));  //dump vec4 to cout with " " as delimiter       
         //merge the 2 copy operation above into one:
         copy(istream_iterator&lt;string&gt;(cin),istream_iterator&lt;string&gt;(),
              ostream_iterator&lt;string&gt;(cout," "));  
            
      3. Reverse iterator: travese container in reversed order
         vector&lt;int&gt; vec = {4,5,6,7};
         reversee_iterator&lt;vector&lt;int&gt;::iterator&gt; ritr;
         for(ritr = vec.rbegin(); ritr!=vec.rend();ritr++)
             cout &lt;&lt; *ritr &lt;&lt; endl;     //prints: 7,6,5,4

      4. Move iterator (c++11): ??

  </Answer>
</QA>

<QA ID="22" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      Why is pre increment (++i) is faster than post increment (i++) ?
  </Question>
  <Answer>
      pre increment is faster because post-increment i++ needs to keep old value before increasing its own value,
      so it needs to create a temporary variable to hold the old value.
  </Answer>
</QA>

<QA ID="23" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Please give some examples of algorithms function usage
  </Question>
  <Answer>
      functions:
      1: min_element(range)
      2: sort(range)
      3: reverse(range)
      4: copy(range, (iterator adapter))
      5: find_if(range, Boolfunction)
      //algorithms - mostly loops

      vector&lt;int&gt; vec = {4,2,5,1,3,9};
      vector&lt;int&gt;::iterator itr = min_element(vec.begin(),vec.end()); //itr =&gt;1

      //Note 1: Algorithm always process range in a half-open way: [begin,end)
      sort(vec.begin(),itr);   //vec:{2,4,5,1,3,9}
      reverse(itr,vec.end());  //vec: {2,4,5,9,3,1}    //itr=&gt;9

      // Note 2: vec2 needs to have at least space for 3 elements:
      vector&lt;int&gt; vec2(3);
      copy(itr,vec.end(),       //Source
            vec2.begin());      //Destination

      //Note 3:  (back_inserter is inserting at the end of a container, I guess)
      vector&lt;int&gt; vec3;
      copy(itr,vec.end(),back_inserter(vec3));  //insert, not overwrite
                   //back_insert_iterator is not efficient, slow, insert 1 at a time
      vec3.insert(vec3.end(),itr,vec.end());    //efficient, fast, insert all at a time

      //Note 4: algorithms with functions
      bool isOdd(int i){
           return i%2;
      }

      int main() {
         vector&lt;int&gt; vec ={2,4,5,9,2}
         vector&lt;int&gt;::iterator itr = find_if(vec.begin(),vec.end(),isOdd);  //itr =&gt;5
      }

      //Note 5: Algorithm with native c++ array
      int arr[4] = {6,3,7,4};
      sort(arr,arr+4);

  </Answer>
</QA>

<QA ID="24" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What are all the implicit member functions of a class? 
     Or what are all the functions which compiler implements for us if we don't define one?
  </Question>
  <Answer>
      1. default ctor
      2. copy ctor
      3. assignment operator
      4. default destructor
      5. address operator
  </Answer>
</QA>

<QA ID="25" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      what is the difference between new and malloc() in terms of memory allocation ?
  </Question>
  <Answer>
      In C++, if the runtime system cannot allocate sizeof(Fred) bytes of memory during p= new Fred(), 
      a std::bad_alloc exception will be thrown. 

      With malloc(), it will return NULL if allocation fails
  </Answer>
</QA>

<QA ID="26" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      Do I need to check for NULL before delete p?
  </Question>
  <Answer>
      No !
  </Answer>
</QA>


<QA ID="27" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      Name 6 operators that cannot be overloaded ?
  </Question>
  <Answer>
      (1) sizeof 
      (2) dot : .  
      (3) star: * 
      (4) arrow: -> 
      (5) Scope resolution operator: :: 
      (6) ?:
  </Answer>
</QA>

<QA ID="28" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      How many ways are there to initialize an int with a constant?
  </Question>
  <Answer>
      (1) int foo = 123;  
      (2) int bar(123);
  </Answer>
</QA>

<QA ID="29" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What are the debugging methods or steps you use ?
  </Question>
  <Answer>
      1. GDB, DBG, Forte, Visual Studio.     (Forte for java ?)
      2. Analyzing the Core dump.
      3. Using tusc to trace the last system call before crash. (HP ?)
      4. Putting Debug statements in the program source code.
  </Answer>
</QA>

<QA ID="30" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
    Why do C++ compilers need name mangling?
  </Question>
  <Answer>
        Name mangling is the rule according to which C++ compiler changes function's name
    into function signature before passing that function to a linker. This is how a linker 
    differentiates between different functions with the same name.
  </Answer>
</QA>

<QA ID="31" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What are C++ storage classes?
  </Question>
  <Answer>
      There are 4 storage classes: 
                       Lifetime:
        1. auto        Function Block       
        2. register    Function Block       
        3. static      Whole Program
        3. extern      Whole Program

         auto: the default. Variables are automatically created and initialized when they 
               are defined and are destroyed at the end of the block containing their 
               definition. They are not visible outside that block.
         (another auto for data type / class) auto i = 1; //i is auto declared as integer, c++11 ?)
         register: a type of auto variable. a suggestion to the compiler to use a 
               CPU register for performance.
         static: a variable that is known only in the function that contains its 
               definition but is never destroyed and retains its value between calls 
               to that function. It exists from the time the program begins execution.
         extern: a static variable whose definition and placement is not determined until
               all object and library modules are combined (linked) to form the executable 
               code file. It can be visible outside the file where it is defined.

  </Answer>
</QA>

<QA ID="32" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is an Iterator class?
  </Question>
  <Answer>
      A class that is used to traverse through the objects maintained by a container class.
  </Answer>
</QA>
<QA ID="33" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      How can I open a stream in binary mode?
  </Question>
  <Answer>
      Use std::ios::binary.
  </Answer>
</QA>
<QA ID="34" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What constant defined in &lt;climits&gt; header returns the number of bits in a char?

      a) CHAR_SIZE    
      b) SIZE_CHAR    
      c) BIT_CHAR   
      d) CHAR_BIT
  </Question>
  <Answer>
      d, CHAR_BIT
  </Answer>
</QA>
<QA ID="35" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      The size_t integer type in C++ is?
  </Question>
  <Answer>
      Unsigned integer of at least 16 bits.

          The size_t type is used to represent the size of an object. 
      Hence, it&#39;s always unsigned. According to the language specification, 
      it is at least 16 bits.
  </Answer>
</QA>
<QA ID="36" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What are 3 float types? if extended precision is required, which one shoule be used ?
  </Question>
  <Answer>
      3 types are: float, double and long double. 
      Should use long double for extended precision.
  </Answer>
</QA>
<QA ID="37" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      If a decimal precision setting is required, what function to use and what header to include?
  </Question>
  <Answer>
      Use setprecision(int p) function and include header &lt;iomanip&gt; for input/output manipulation
  </Answer>
</QA>
<QA ID="38" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      In which type are the enumerators stored by the compiler?

      a) string
      b) integer
      c) float
      d) none of the mentioned

  </Question>
  <Answer>
      b
  </Answer>
</QA>
<QA ID="39" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is the default calling convention for a compiler in c++?

      a) __cdecl
      b) __stdcall
      c) __pascal
      d) __fastcall	
  </Question>
  <Answer>
      a
  </Answer>
</QA>
<QA ID="40" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      Function pointer example
  </Question>
  <Answer>
      #include &lt;iostream&gt;
      using namespace std;

      int add(int first, int second){
         return first + second + 15;
      }

      int operation(int first, int second, int(*functocall)(int, int)){
         return (*functocall)(first, second);
      }

      int main(){
        int  a;
        int(*plus)(int, int) = add;
        a = operation(15, 10, plus);
        cout &lt;&lt; a;
        return 0;
      }
  </Answer>
</QA>

<QA ID="41" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is keyword volatile and how to use it ?
  </Question>
  <Answer>
        C's volatile keyword is a qualifier that is applied to a variable when it is declared. 
      It tells the compiler that the value of the variable may change at any time--without 
      any action being taken by the code the compiler finds nearby. 

      volatile is used to prevent changes from compiler optimization; 

      2 ways to declare it:

      volatile uint16_t x; 
      uint16_t volatile y;

      if you really must have a volatile pointer to a volatile variable, you'd write:

      uint16_t volatile * volatile p_y;

      It is used for things like memory-mapped I/O registers

      Proper Use of C's volatile Keyword:

        A variable should be declared volatile whenever its value could change unexpectedly. 
      In practice, only three types of variables could change:

      1. Memory-mapped peripheral registers
      2. Global variables modified by an interrupt service routine
      3. Global variables accessed by multiple tasks within a multi-threaded application

          Embedded systems contain real hardware, usually with sophisticated peripherals. 
      These peripherals contain registers whose values may change asynchronously to the 
      program flow. As a very simple example, consider an 8-bit status register that is 
      memory mapped at address 0x1234. It is required that you poll the status register 
      until it becomes non-zero. The naive and incorrect implementation is as follows:

      uint8_t * p_reg = (uint8_t *) 0x1234;

      // Wait for register to read non-zero 
      do { ... } while (0 == *p_reg)

      This code will almost certainly fail as soon as you turn compiler optimization on.
  </Answer>
</QA>

<QA ID="42" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      By default members of a structure are: 
       A - private
       B - protected
       C - public
       D - Access specifiers not applicable for structures
  </Question>
  <Answer>
      C.  default members of a class is private, structure is public 
  </Answer>
</QA>

<QA ID="43" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      Can a constructor be virtual
  </Question>
  <Answer>
      No! (but why ? explain!)
  </Answer>
</QA>

<QA ID="44" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is the output of the following program ?
       
      #include &lt;iostream&gt;
      using namespace std;

      class Base{
      public:
          void f(){ cout &lt;&lt; "base\n"; }
      };

      class Derived:public Base {
      public:
         void f() { cout &lt;&lt; "Derived\n";}
      };

      main(){
         Derived obj;
         obj.Base::f();
      }
       
      A - Base
      B - Derived
      C - Compile error
      D - None of the above    
  </Question>
     
  <Answer>
      A
  </Answer>
</QA>

<QA ID="45" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     #include &lt;iostream&gt;

     using namespace std;
     class abc{
        void f();
        void g();
        int x;
     };

     main(){
        cout &lt;&lt; sizeof(abc)&lt;&lt;endl;
     }

     A: 12
     B: 4
     C: 8
     D: Compile error
  </Question>
  <Answer>
      B.  it is the size of all variables, function declaration does not take any space
  </Answer>
</QA>

<QA ID="46" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     In the following program, is f() overloaded ?
 
     void f(int x){}
     void f(signed x){}
     main() {}

  </Question>
  <Answer>
      No. Because Plain int is the same as signed, and is the same as signed int too.
  </Answer>
</QA>
<QA ID="47" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      Choose the respective delete operator usage for the expression: ptr=new int[100];
 
      A: delete ptr;
      B: delete ptr[];
      C: delete [] ptr;
      D: []delete ptr;
  </Question>
  <Answer>
      C
  </Answer>
</QA>
<QA ID="48" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      An exception is 
    
      A: Runtime error
      B: Compile time error
      C: Logical error
      D: None of the above

  </Question>
  <Answer>
      D. Exception is not an error. 
         Difference between Exception and Error is: 
         Exceptions are those which can be handled at the run time whereas errors cannot be handled.
  </Answer>
</QA>
<QA ID="49" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      Pick up the valid declaration for overloading ++ in postfix form where T is the class name:
     
      A: T operator++();
      B: T operator++(int);
      C: T &#38; operator++();
      D: T &#38; operator++(int);
  </Question>
  <Answer>
      B. (but why ? look it up !)
  </Answer>
</QA>
<QA ID="50" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      HAS-A relationship between the classes is shown through:

      A: Inheritance
      B: Container classes
      C: Polymorphism
      D: None of the above
  </Question>
  <Answer>
      Not A, It is B ! For example: A car is-a vehicle but A car has-a steering wheel
  </Answer>
</QA>
<QA ID="51" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is the output of the following program ?
 
     #include &lt;iostream&gt;

     using namespace std;
     void main(){
         char *s = "Fine";
         *s = 'N';
         cout &lt;&lt; s &lt;&lt; endl;
     }

     A: Fine
     B: Nine
     C: Compile error
     D: Runtime error

  </Question>
  <Answer>
      D. Not B: Runtime error: Exception thrown: write access violation

      if it was the line: char s[]="Fine"; 
      the answer would be B:

      This is because char * s="asdf"; is equivlant of const char *s ="asdf";

      A literal string in a C program is considered to be read-only and the 
      compiler/linker/loader may arrange for the memory of that string to be in 
      memory that is protected against writing.

  </Answer>
</QA>
<QA ID="52" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is the output of the following program ?
 
     #include &lt;iostream&gt;

     using namespace std;
     void main(){
         class student{
            int rno=10;
         } v;
         cout &lt;&lt; v.rno &lt;&lt; endl;
     }

     A: 10
     B: Garbage
     C: Compile error
     D: Runtime error

  </Question>
  <Answer>
      Not A, But C: Compile error. Because it is trying to access private member rno!
      class member is default to private. The test is testing for that knowledge !
  </Answer>
</QA>
<QA ID="53" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is the output of the following program ?

     #include &lt;iostream&gt;

     using namespace std;
     void main(){
         short unsigned int i=0;
         cout &lt;&lt; i-- ;
     }

     A: 0
     B: Compile error
     C: 65535
     D: 32767
  </Question>
  <Answer>
      Not C, it is A ! Because i-- is post increment, it will return 0 before 
      decreases and becomes 65535 (All bit set, since it is unsigned, it is 65535)
  </Answer>
</QA>

<QA ID="54" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Which operator is required to be overloaded as member function only ?

     A: _
     B: __
     C: ++ (postfix version)
     D: =
  </Question>
  <Answer>
      D. The "=" can not be overloaded as an independent function, like other operators do.
  </Answer>
</QA>

<QA ID="55" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is the output of the following program ?

     #include &lt;iostream&gt;

     using namespace std;
     class abc {
     public:
        int i;
        abc(int i) {
           i=i;
        }
     };
     void main(){
        abc m(5);
        cout &lt;&lt; m.i;
     }

     A: 5
     B: Garbage
     C: Error at the statement i=i;
     D: Compile error: i declared twice.

  </Question>
  <Answer>
      Not A, it is B ! Because i in constructor is defined in constructor as int, which
      hides the class variable i, so the 2 i's in the constructor are all i as the argument
      and the class variable i never get a change to be initialized and left with garbage!
  </Answer>
</QA>
<QA ID="56" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is the output of the following program ?

     #include &lt;iostream&gt;

     void main(){
        int r, x=2;
        float y=5;
        r=y%x;
        cout &lt;&lt; r;
     }

     A: 1
     B: 0
     C: 2
     D: Compile error

  </Question>
  <Answer>
      Not A, it is D ! Because y can't be float, it must be an integer to be meaningful.
  </Answer>
</QA>

<QA ID="57" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is a generic class ?

     A: Function template
     B: Class template
     C: inherited class
     D: None of the above
  </Question>
  <Answer>
     D. or the answer should be template class, not class template!
     Templates are the foundation of generic programming, which involves writing code in a way 
     that is independent of any particular type. A template is a blueprint or formula for 
     creating a generic class or a function.    
  </Answer>
</QA>

<QA ID="58" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Identify the c++compiler of Linux:

     A: cpp
     B: g++
     C: Borland
     D: vc++

  </Question>
  <Answer>
     B, not A !
  </Answer>
</QA>

<QA ID="59" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is the output of the following program ?

     #include &lt;iostream&gt;

     void main(){
        float t=2;
        switch(t){
        case 2: cout &lt;&lt "Hi";
        default:cout &lt;&lt; "Hello";
        }
     }

     A: Hi
     B: HiHello
     C: Hello
     D: Error
  </Question>
  <Answer>
     D.  Because the switch only takes integer !
  </Answer>
</QA>
<QA ID="60" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Which is the storage specifier used to modify the member variable even though
     the class object is a constant object ?

     A: auto
     B: register
     C: static
     D: mutable
  </Question>
  <Answer>
     D. Example Snippet: 
     class Foo {
     private:
        mutable bool done;
     public:
        void doSomething() const{    //&lt;==notice the keyword const
            done=true;               //&lt;==but can still modify mutable vars
        }
     };
  </Answer>
</QA>
<QA ID="61" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     That is the full form of RTTI ?

     A: Runtime type identification
     B: Runtime template identification
     C: Robust Template Type Inheritance
     D: None of the above

  </Question>
  <Answer>
     A
  </Answer>
</QA>

<QA ID="62" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is the output of the following program ?

     #include &lt;iostream&gt;
      
     using namespace std; 
     void main(){
        char s[]="C++";
        cout &lt;&lt; s &lt;&lt;" ";
        s++;
        cout &lt;&lt; s &lt;&lt;" ";
     }

     A: C++ C++
     B: C++ ++
     C: ++ ++
     D: Compile error
  </Question>
  <Answer>
     D, Not B: although in char * s and char s[], s can be both used as an pointer, 
     but s[] can not be used to do pointer math operations like post increment calculations!
  </Answer>
</QA>
<QA ID="63" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     With respective to streams, operator &gt;&gt; is called as

     A: Insertion operator
     B: Extraction operator
     C: Right shift operator
     D: Left shift operator
  </Question>
  <Answer>
     B. &gt;&gt; is extraction operator and &lt;&lt; is insertion operator!
  </Answer>
</QA>
<QA ID="64" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Which feature of the OOP gives the concept of reusability ?

     A: Abstraction
     B: Encapsulation
     C: Inheritance
     D: None of the above
  </Question>
  <Answer>
     C
  </Answer>
</QA>

<QA ID="65" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is the output of the following program ?

     #include &lt;iostream&gt;
      
     using namespace std; 
     void main(){
        int *p= new int;
        delete p;
        delete p;
        cout &lt;&lt; "Done";
     }

     A: Done
     B: Compile error
     C: Runtime error
     D: None of the above
  </Question>
  <Answer>
     C !, but why ? do some research on this when you have time !!!
  </Answer>
</QA>

<QA ID="66" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      what is the difference between stack and heap ?
  </Question>
  <Answer>
     Stack is used for static memory allocation and Heap for dynamic memory allocation.  
       
     Use stack if you know the size before compile time.
     Use heap if you do not know the size until runtime.

     In a multi-threaded situation each thread will have its own completely independent 
     stack but they will share the heap. Stack is thread specific and Heap is application 
     specific. The stack is important to consider in exception handling and thread executions.

  </Answer>
</QA>

<QA ID="67" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     A trigraph character begins with:

     A: #
     B: ##
     C: ?
     D: ??

  </Question>
  <Answer>
     D.  In computer programming, digraphs and trigraphs are sequences of 
     two and three characters, respectively, that appear in source code and, 
     according to a programming language's specification, should be treated 
     as if they were single characters.

     According to C++'03 Standard 2.3/1:

     Before any other processing takes place, each occurrence of one of the 
     following sequences of three characters (trigraph sequences) is replaced 
     by the single character indicated in following Table:

    ----------------------------------------------------------------------------
    | trigraph | replacement | trigraph | replacement | trigraph | replacement |
    ----------------------------------------------------------------------------
    | ??=      | #           | ??(      | [           | ??&lt;     | {            |
    | ??/      | \           | ??)      | ]           | ??&gt;     | }            |
    | ??&#39;      | ^           | ??!      | |           | ??-     | &apos;            |
    ----------------------------------------------------------------------------
  </Answer>
</QA>
<QA ID="68" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     "cin" is an __

     A: Class
     B: Object
     C: Package
     D: Namespace
  </Question>
  <Answer>
     B, an object !
  </Answer>
</QA>
<QA ID="69" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What are the 4 operators that have to be overloaded as members ?
  </Question>
  <Answer>
     1: The assignment operator=()
     2: The function call operator()()
     3: The subscript operator[]()
     4: The class member access operator->()
  </Answer>
</QA>
<QA ID="70" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Choose the option not applicable for the constructor:
     
     A: Cannot be called explicitly
     B: Cannot be overloaded
     C: Cannot be overridden
     D: None of the above
  </Question>
  <Answer>
     C, Cannot be overidden.
  </Answer>
</QA>
<QA ID="71" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     From the below class choose the proper definition of the member function f().

     A: template&lt;class T&gt;
        void abc&lt;T&gt;::f(){}

     B: template&lt;class T&gt;
        void abc::f(){}

     C: template&lt;T&gt;
        void abc&lt;class T&gt;::f(){}

     D: template&lt;T&gt;
        void abc&lt;T&gt;::f(){}
  </Question>
  <Answer>
     A
  </Answer>
</QA>
<QA ID="72" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is the size of "int" ?
     
     A: 2
     B: 4
     C: 8
     D: Compiler dependent
  </Question>
  <Answer>
     D
  </Answer>
</QA>

<QA ID="73" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     i) Exceptions can be traced and controlled using conditional statements
     ii) For critical exceptions compiler provides the handler

     A: Only (i) is true
     B: Only (ii) is true
     C: Both (i) and (ii) are true
     D: Both (i) and (ii) are false
  </Question>
  <Answer>
     B
  </Answer>
</QA>
<QA ID="74" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     How do I initialize a pointer to a function ?
  </Question>
  <Answer>
     void fun(int a){}
     void main(){
        void (*fp)(int);    //declare a pointer fp to a function
        fp=fun;             //initialize the pointer
        fp(1);              //call the function
     }
  </Answer>
</QA>
<QA ID="75" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What does extern mean in a function declaration ?
  </Question>
  <Answer>
     Extern indicates that the function&apos;s definition is in another source file. 
     But there is no formal difference between extern int a (); and int a (); 
  </Answer>
</QA>
<QA ID="76" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is a pointer ?
  </Question>
  <Answer>
     A pointer is a variable which contains the address in memory of another variable.
  </Answer>
</QA>
<QA ID="77" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is a NULL pointer ?
  </Question>
  <Answer>
     A NULL pointer is a pointer that does not point to any object or function
  </Answer>
</QA>
<QA ID="78" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     There are three major features in object-oriented programming, what are they ?
  </Question>
  <Answer>
     1: Encapsulation
     2: Inheritance
     3: Polymorphism
  </Answer>
</QA>
<QA ID="79" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What are 3 kinds of polymorphism that C++ supports ?
  </Question>
  <Answer>
     1: ad-hoc polymorphism (through function overloading, and implicit conversions), 
     2: parametric polymorphism (through template specializations and tag dispatching), 
     3: subtype polymorphism (through the virtual function call mechanism).

     The first two (or sometimes just the template-based one) are also referred to as 
     static polymorphism, compared to the dynamic polymorphism of virtual calls.
  </Answer>
</QA>
<QA ID="80" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is function overloading ?
  </Question>
  <Answer>
     Function overloading is a programming concept that allows programmers to define 
     two or more functions with the same name and in the same scope. Each function has 
     a unique signature, which is derived from:

      1: function name
      2: number of arguments
      3: arguments' type
      4: arguments' order

      return type is not included in making function signature
  </Answer>
</QA>
<QA ID="81" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What are the 2 major cause of stack overflow ?
  </Question>
  <Answer>
     1: Infinite or very deep recursive call
     2: Assign a very large size variable on stack
  </Answer>
</QA>

<QA ID="82" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is cout and what is cin in STL ?
  </Question>
  <Answer>
     std::cout and std::cin are global objects of classes std::ostream and std::istream 
     respectively, of which they've overloaded operator &lt;&lt; and &gt;&gt; 
  </Answer>
</QA>

<QA ID="83" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     how can we pass an object into a thread by reference so that we can get the return value from it?
  </Question>
  <Answer>
     by using std::ref(obj);
 
     Snippet:
     class Fnctor{
     public:
        void operator()(string &amp; msg){
           cout &lt;&lt; "t1 says: "&lt;&lt; msg &lt;&lt; endl;
           msg="Trues is the mother of deceit";        //pass back a diff msg to show it is by ref
        }
     };
     void main(){
       string s="main org msg";     //notice how to pass a param to thread the line below, use 2nd parm to thread
       std::thread t1((fnctor())), std:ref(s));  //extra pair of () is needed here to make t1 not a def of fn
       t1.join();                   //if not use ref() here, it will auto use pass by value even though callee is &#38;msg 
       cout &lt;&lt; "From main: " &lt;&lt; s &lt;&lt; endl;
     }

     However, this could cause the 2 threads (parent and child) both have access to the same object, 
     so, access to it needs to be synchronized between the 2 threads.
     If this situation is required, we recommend using std::async() instead of spawn a thread!

     * To pass an object to thread by value is costly, by reference is not safe. 
      using move is both safe and efficient:
      std::thread t1((Fnctor()),std::move(s));

      * thead can not be copied, only be moved:
      std::thread t2 = std::move(t1);
      t2.join();

      * to get thread ID using:
       std::thread_thread::get_id()
       or
       t2.get_id();
  </Answer>
</QA>

<QA ID="84" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Through what do threads communicate with each other ?
     Through what do processes communicate ?
  </Question>
  <Answer>
     Threads communicate through shared memory
     Processes communicate through IPC, interprocess communication like files, pipes, message queues etc.
     Shared memory is faster than IPC.
     Threads can not be run on different computers.
     Processes can be run on a distributed system
  </Answer>
</QA>

<QA ID="85" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     How to use std::thread to spawn a thread ?
  </Question>
  <Answer>
     Snippet:

     void function_1(){}
     void main(){
        std::thread t1(function_1);  //t1 starts running
        t1.join() // main thread waits for t1 to finish here               
     }

     After a thread is spawn, it can join in or detach from 
     main thread once.
     
     To tell if a thread is joinable, do test first:

     if(t1.joinable())
        ti.join();

     //if not joinable, it will crash if you call join()
     //the thread can also detach from main thread:

      t1.detach(); //t1 will run freely, a daemon process, 
     // c++ runtime library will reclaim the resources when t1 finishes

     //if t1 is finished before it is detached or joined the main thread
     //the process will end!, so it has to be joined or detached before it finishes!

  </Answer>
</QA>

<QA ID="86" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is daemon ?
  </Question>
  <Answer>
     A daemon is a long-running background process that answers requests for services. 
     The term originated with Unix, but most operating systems use daemons in some 
     form or another. In Unix, the names of daemons conventionally end in "d". Some 
     examples include inetd , httpd , nfsd , sshd , named , and lpd 
  </Answer>
</QA>

<QA ID="87" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is lpd process doing ?
  </Question>
  <Answer>
     The lpd daemon places files specified in print requests in the directory 
     /var/spool/lpd. The print request is then managed by the qdaemon and the 
     appropriate backend (usually piobe) on the remote server. The /etc/locks/lpd file 
     contains the process ID of the currently running instance of the lpd daemon.

     Key words: /var/spool/lpd       //print request queue
                /etc/locks/lpd       //process ID
  </Answer>
</QA>

<QA ID="88" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is Spurious wakeup ?
  </Question>
  <Answer>
     Spurious wakeup describes a complication in the use of condition variables as provided 
     by certain multithreading APIs such as POSIX Threads and the Windows API.
     It is a wait-signal setup for multi-thread synchronizing machinism: 

     /* In any waiting thread: */
     while(!buf->full)
        wait(&#38;buf->cond, &#38;buf->lock);

     /* In any other thread: */
     if(buf->n >= buf->size){
	buf->full = 1;
	signal(&#38;buf->cond);
     }
     
  </Answer>
</QA>
<QA ID="89" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What does POSIX stand for ?
  </Question>
  <Answer>
     It stands for Portable Operating System Interface (POSIX). It is a family of standards 
     specified by the IEEE Computer Society for maintaining compatibility between operating 
     systems. POSIX defines the application programming interface (API), along with command
     line shells and utility interfaces, for software compatibility with variants of Unix 
     and other operating systems.
  </Answer>
</QA>
<QA ID="90" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is called preemptive multitasking ?
  </Question>
  <Answer>
     Preemptive multitasking is a task in which a computer operating system uses some criteria 
     to decide how much time to allocate to any one task before giving another task a turn to use 
     the operating system. 
     The act of taking control of the operating system from one task and giving it to another 
     task is called preempting.
  </Answer>
</QA>
<QA ID="91" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is SaaS ?
  </Question>
  <Answer>
     Software as a service (SaaS) is a software licensing and delivery model in which 
     software is licensed on a subscription basis and is centrally hosted. SaaS is typically 
     accessed by users using a thin client via a web browser. SaaS has become a common delivery 
     model for many business applications, including office software, messaging software etc.
  </Answer>
</QA>
<QA ID="92" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is RESTful ?
  </Question>
  <Answer>
     Representational State Transfer (REST) is an architectural style that defines a set of 
     constraints and properties based on HTTP. Web Services that conform to the REST architectural 
     style, or RESTful web services, provide interoperability between computer systems on the Internet. 
     REST-compliant web services allow the requesting systems to access and manipulate textual 
     representations of web resources by using a uniform and predefined set of stateless operations. 
     Other kinds of web services, such as SOAP web services, expose their own arbitrary sets of 
     operations.
  </Answer>
</QA>
<QA ID="93" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     How to determin how many threads to use for the best performance ?
  </Question>
  <Answer>
     use this API function call:
     std::thread::hardware_concurrency();
  </Answer>
</QA>
<QA ID="94" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     How to avoid deadlock ?
  </Question>
  <Answer>
     1: Avoid using more than one mutex at the same time
     2: Avoid calling user function while holding one or more mutex
     3: Use std::lock() to lock more than one mutex if more than one mutex are needed.
     4: Lock more than one mutexes in the same order

  </Answer>
</QA>
<QA ID="95" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is a race condition ?
  </Question>
  <Answer>
     Race condition is the behavior of software where the output is dependent on the sequence or timing 
     of the other threads in multi-threaded application. 
  </Answer>
</QA>
<QA ID="96" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     How to use mutex in c++ ?
  </Question>
  <Answer>
     1. Declare an mutex object:               std::mutex mu;  //accessible by all theads like a global variable
     2. Lock it before access shared resource: mu.lock();
     3. unlock it after access:                mu.unlock();
  </Answer>
</QA>
<QA ID="97" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Why the direct use of mutex is not recommended ? 
     What is recommended for using mutex ?
  </Question>
  <Answer>
     When mutex is used directly, if an exceptions happens while a thread is accessing the protected 
     resources while mutex is locked, then there would be no way to unlock the mutex and all the other 
     threads will be blocked from accessing forever.

     std::lock_guard class template is recommended to use with mutex. so, just use following line
     std::lock_guard&lt;std::mutex&gt; guard(mu);
     in the place of mu.lock() and remove the mu.unlock().
     when exception happens, guard will be destroyed and its destructor will auto unlock the mutex (RAII)
  </Answer>
</QA>
<QA ID="98" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is data race, now to avoid it ?
  </Question>
  <Answer>
     A data race occurs when 2 instructions from different threads in a single process access the same memory 
     location concurrently, and at least one of these accesses is a write and there is no synchronization 
     that is mandating any particular order among these accesses.

     To avoid data race:
      1. Use mutex to synchronize the data access
      2. Never leak a handle of data to outside
      3. Design interface appropriately
  </Answer>
</QA>
<QA ID="99" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is baffling ?
  </Question>
  <Answer>
     Very Strange     
     usage example:it appears baffling
  </Answer>
</QA>
<QA ID="100" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Which of the following is a pointer pointing to function ?
     
     A: int *a()
     B: int a(*a)
     C: int a()*
     D: int (*a)
  </Question>
  <Answer>
     A, I think !
  </Answer>
</QA>
<QA ID="101" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What are the 9 unary operators in c ?
  </Question>
  <Answer>
     1: - minus
     2: + plus
     3: ! logical negation
     4: ++ prefix/postfix increment
     5: -- prefix/postfix decrement
     6: &amp;  Address operator
     7: *  indrection operator
     8: () cast operator
     9: sizeof() operator
  </Answer>
</QA>
<QA ID="102" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is the output of the following program ?
     ...
     void main(){
        char c[]={'a','b','c','d'};
        char d[]="abcd";
        printf("%d - %d",sizeof(c),sizeof(d));
     }

     A: 4 - 4
     B: 4 - 5
     C: 5 - 5 
     D: 1 - 1
  </Question>
  <Answer>
     B. Length of a string includes the ending 0, size of array has no ending 0
  </Answer>
</QA>
<QA ID="103" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     In C, which of the following options is not a predefined function in string ?

     A: strcpy()
     B: strlen()
     C: strnicmp()
     D: None of the given options
  </Question>
  <Answer>
     D. strnicmp() is a predefined function !!!
  </Answer>
</QA>
<QA ID="104" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     Which of the following UNX commands is used to resursive listing of files ?
     
     A: ls -r
     B: ls -R
     C: ls -a
     D: ls -F
  </Question>
  <Answer>
     B
  </Answer>
</QA>
<QA ID="105" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     The mv commaind in UNIX will chagne:
 
     A: The i-node number
     B: only the directory entry
     C: directory and the i-node
     D: None of the options above

  </Question>
  <Answer>
     B
  </Answer>
</QA>
<QA ID="106" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     When used without arguments, the cd command in UNIX will:

     A: change to next directory
     B: bring back to previous directory
     C: bring back to home directory
     D: display an error
  </Question>
  <Answer>
     C
  </Answer>
</QA>
<QA ID="107" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     What does the cat command in UNIX do  ?

     A: Create a file
     B: Displays the contents of file
     C: Concatenates two files
     D: All of the given options
  </Question>
  <Answer>
     D, not B!
     You can create a new file with the name file1.txt using the following cat command 
     and you can type the text you want to insert in the file. Make sure you type 
     &apos;Ctrl-d&apos; at the end to save the file.

     cat > file1.txt
  </Answer>
</QA>
<QA ID="108" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     Which of the following UNIX commands is not a filter ?
     
     A: sort
     B: grep
     C: cal
     D: cut
  </Question>
  <Answer>
     C
  </Answer>
</QA>
<QA ID="109" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Which of the following UNIX commands cannot be used for communication in UNIX ?
     
     A: wall
     B: write
     C: mail
     D: more     
  </Question>
  <Answer>
     D
  </Answer>
</QA>
<QA ID="110" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is Unix command wall for ?
  </Question>
  <Answer>
     wall (an abbreviation of write to all) is a Unix command-line utility that displays the contents of a file 
     or standard input to all logged-in users. It is typically used by root to send out shutting down message 
     to all users just before poweroff.
  </Answer>
</QA>
<QA ID="111" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is write command in UNIX ?
  </Question>
  <Answer>
     In Unix and Unix-like operating systems, write is a utility used to send messages to another user 
     by writing a message directly to another user's TTY
  </Answer>
</QA>
<QA ID="112" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Fill inthe blank:
     Function sub() is part of ____.

     A: sed
     B: awk
     C: grep
     D: nawk
     E: ak
  </Question>
  <Answer>
     B, ?
  </Answer>
</QA>
<QA ID="113" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Which of the following commands will you use to find a character or a word inside a string ?
     A: search
     B: find
     C: get
     D: grep
     E: wc -c
  </Question>
  <Answer>
     D, not B!
  </Answer>
</QA>
<QA ID="114" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     While asking for input from user, how to get first name in fname variable and lastname in lname 
     variable. Which of the following commands will allow you to do so ?
    
     A: By default, input will go to fname. you need to separate them inside code
     B: By default, input will go to lanme, you need to separate them inside code
     C: get fname lname
     D: read fname lname
     E: getname fname lname

  </Question>
  <Answer>
     D
  </Answer>
</QA>
<QA ID="115" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What software tool have you used for managing projects, tracking bugs ?
  </Question>
  <Answer>
     I have used: Jenkins, Rally, Conflunce, MKS (Application lifecycle management, used in Airblue)
  </Answer>
</QA>
<QA ID="116" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     what does the keyword explicit for ?
  </Question>
  <Answer>
     Prefixing the explicit keyword to the constructor prevents the compiler from using that constructor 
     for implicit conversions. You have to cast it to do the conversion

     The explicit keyword prevents an implicit conversion
  </Answer>
</QA>
<QA ID="117" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is the difference between pointer and reference ?
  </Question>
  <Answer>
     A difference between pointers and references is that a pointer is an indepedent variable and can be 
     assigned NEW address values; whereas a reference, once assigned, can never refer to any new object 
     until the variable goes out of scope.

     snippet example:

       string s1("Nancy");
       string s2("Clancy");

       string &amp;rs = s1;  // rs refers to s1
       string *ps = &amp;s1; // ps points to s1

       Note: this looks like you can change what a reference refers, it actuallly changes refered variable value:
       rs = s2;          // rs still refers to s1,   
                         // but s1's value is now "Clancy"

       ps = &amp;s2;         // ps now points to s2; s1 is unchanged

       =========================================================
       The example shows the difference:
 
       reference assignment:  rs=s1;   //changes the value of variable it referes
       pointer assignment:    ps=&amp;s1;  //changes the address value the ps holds, make it points to a new 
                                       //variable holding the assigned value

       So, we can say that a reference to a variable is just an alias for the variable!
  </Answer>
</QA>
<QA ID="118" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
    What are 4 C++ style casts ?
  </Question>
  <Answer>
    C++ introducing 4 new cast operators:
     
    1: static_cast: for c cast except casting away the const
    2: const_cast: cast away the const-ness
    3: dynamic_cast: safe cast down or across an inheritance hierarchy casting from base into derived class objects.
                       return null if failed. no cast away const-ness
    4: reinterpret_cast: perform type conversions whose result is always implementation-defined. Used for casting function pointer types

    Snippet example:

    double result=(double)A/B;
    should become:
    double result=static_cast&lt;double&gt;A/B;
  </Answer>
</QA>
<QA ID="119" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Why should we always provide default constructors when we design a class ?
  </Question>
  <Answer>
     Default constructor is a one without argument!
     If a class lacks a default constructor, its use may be problematic in three contexts:

     1: Creation of arrays: when creating an array of objects, default constructor is always called.

     2: They are ineligible for use with many template-based container classes. Classes without default constructors 
        will be incompatible with many templates.

     3: Virtual base classes lacking default constructors are a pain to work with. That's because the arguments for 
        virtual base class constructors must be provided by the most derived class of the object being constructed. 
        As a result, a virtual base class lacking a default constructor requires that all classes derived from that 
        class - no matter how far removed - must know about, understand the meaning of, and provide for the virtual 
        base class&apos;s constructors&apos; arguments. Authors of derived classes neither expect nor appreciate 
        this requirement.
  </Answer>
</QA>
<QA ID="120" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is std::auto_ptr pointer in C++ standard library ?
  </Question>
  <Answer>
     std::auto_ptr was a class template available in the C++ Standard Library 
     (declared in the &lt;memory&gt; header file) that provided some basic RAII features for 
     C++ raw pointers. It has been replaced by the unique_ptr class.
  </Answer>
</QA>
<QA ID="121" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is difference between a member function and non-member function ?
  </Question>
  <Answer>
     3 differences:

     1: A non-member function always appears outside of a class
     2: They are called differently. for member fuction calls you have to specify object
     3: Member functions can be virtual and non-member functions can't.
  </Answer>
</QA>
<QA ID="122" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What are the cases where you should make a function a member function ?
  </Question>
  <Answer>
     3 cases:
     
     1) operator &lt;&lt; and operator &gt;&gt;
     2) Only non-member functions get implicit type conversions on all arguments
         so, if that is a need, make it a non-member functions. 
     3) if it also need to access non-public members of a class, make it a friend of the class.
  </Answer>
</QA>
<QA ID="123" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Why cannot the operator &lt;&lt; and &gt;&gt; be overloaded as member functions ?
  </Question>
  <Answer>
     When overloaded as a member function, a &lt;&lt; b is interpreted as a.operator&lt;&lt;(b), so it only takes 
     one explicit parameter (with this as a hidden parameter).

     Since this requires that the overload be part of the class used as the left-hand operand, it's not useful 
     with normal ostreams and such. It would require that your overload be part of the ostream class, not part 
     of your class. Since you're not allowed to modify ostream, you can't do that. That leaves only the global 
     overload as an alternative.

  </Answer>
</QA>
<QA ID="124" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     why should we avoid data members in public interface ??
  </Question>
  <Answer>
     1: Private variables help prevent people from depending on certain parts of your code
        It is easier to provide a steady interface when your design of the class changes.
     2: Public variables can be accessed from anywhere, makeing troubleshooting harder
  </Answer>
</QA>
<QA ID="125" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is difference between private and public inheriance ?
  </Question>
  <Answer>
     With private inheritance, public and protected member of the base class become private 
     members of the derived class
  </Answer>
</QA>
<QA ID="126" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     How to minimize compilation dependencies between files ?
  </Question>
  <Answer>
     1. Avoid using objects when object references and pointers will do.
     2. Use class declarations instead of class definitions whenever you can
     3. Don't #include header files in your header files unless your headers won't compile without them
  </Answer>
</QA>
<QA ID="127" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     How to keep people from calling an compiler auto generated member function ?
  </Question>
  <Answer>
     By declaring the member function explicitly and make it private!
  </Answer>
</QA>
<QA ID="128" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     How to declare const pointer and const data ?
  </Question>
  <Answer>
     char *p         = "Hello";       // non-const pointer, non-const data
     const char *p   = "Hello";       // non-const pointer, const data
     char * const p  = "Hello";       // const pointer, non-const data
const char * const p = "Hello";       // const pointer, const data
  </Answer>
</QA>
<QA ID="129" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Pass by reference or by value ?
  </Question>
  <Answer>
     
	1: pass-by-value is expensive: copy constructor and destructor will be called
	2: pass-by-reference is efficient: no copy constructor and destructor will be called
	3: pass-by-reference can avoid slicing problem

           if you have a small object - an int, for example - it may actually be more efficient 
        to pass it by value than to pass it by reference

  </Answer>
</QA>
<QA ID="130" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Why should we avoid overloading a function on a pointer and a numerical type ?
  </Question>
  <Answer>
     Because a pointer is actually a number, it will be confusing!
  </Answer>
</QA>
<QA ID="131" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What data members of a class must be initialized with initialization list ?
  </Question>
  <Answer>
     const members and referece members. Because those members can only be initialized, 
     never assigned inside constructor
  </Answer>
</QA>
<QA ID="132" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     How to order the initialization list ?
  </Question>
  <Answer>
     List members in an initialization list in the order in which they are declared.
     base class data members are initialized before derived class data members
  </Answer>
</QA>
<QA ID="133" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Why should we always make the base class&apos;s destructor virtual ?
  </Question>
  <Answer>
     When you try to delete a derived class object through a base class pointer and the base class
     has a non virtual destructor, the results are undefined. What often happens at runtime is that 
     the derived class's destructor is never called.
  </Answer>
</QA>
<QA ID="134" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     When should we not make a class&apos;s destructor virtual ? why ?
  </Question>
  <Answer>
     When a class is not intended to be used as a base class, making the destructor virtual is usually 
     a bad idea, Because:
     1: won&apos;t fit a 32 bit registers. 
     2: its object size doubles. 
     3: It will create a virtual table for virtual function pointers
  </Answer>
</QA>
<QA ID="135" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Why do you still need definition block when you declare a pure virtual destructor ?
  </Question>
  <Answer>
     You need this definition, because the way virtual destructors work is that the most derived 
     class&apos;s destructor is called first, then the destructor of each base class is called. 
     That means that compilers will generate a call to base class destructor even though the class
     is abstract, so you have to be sure to provide a body for the function. If you don't, the 
     linker will complain about a missing symbol.
  </Answer>
</QA>
<QA ID="136" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Why should we always return a reference to *this in member function operator=  ?
  </Question>
  <Answer>
     Because if you return void, it will prevent chains of assignment like x1=x2=x3=0; prevent 
     implicit type conversions at call sites, or both.
  </Answer>
</QA>
<QA ID="137" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Which of the following C++ classes is used for opening agile as read-only?

     A: ofstream
     B: ifstream
     C: fstream
     D: iostream
  </Question>
  <Answer>
     B
  </Answer>
</QA>
<QA ID="138" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Which one of the following programs do you run on your computer in order to allow connections 
     to your server using a serial terminal connected to a serial port ?

	a: login
	b: getty
	c: sh
	d: kermit
	e: tcflow
  </Question>
  <Answer>
     b.  getty, short for get &quot;teletype&quot;, is a Unix program running on a host computer 
     that manages physical or virtual terminals (TTYs). When it detects a connection, it prompts 
     for a username and runs the &apos;login&apos; program to authenticate the user.
  </Answer>
</QA>
<QA ID="139" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     which one of the following signal commands do you use to determin which siganls have been 
     sent to a process but which have not yet been processed?

	A: sigprocmask
	B: sigwaiting
	C: sigsent
	D: sigpending
	E: signal
  </Question>
  <Answer>
      D
  </Answer>
</QA>
<QA ID="140" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Explain how 2 processes communicate using message queue in unix.
  </Question>
  <Answer>
     Two (or more) processes can exchange information via access to a common system message queue. 
     The sending process places a message onto a queue which can be read by another process. Each 
     message is given an identification or type so that processes can select the appropriate message. 
     Process must share a common key in order to gain access to the queue in the first place.

     IPC messaging lets processes send and receive messages, and queue messages for processing in 
     an arbitrary order. Each IPC message has an explicit length. Messages can be assigned a specific 
     type. Because of this, a server process can direct message traffic between clients on its queue
     by using the client process PID as the message type. For single-message transactions, multiple 
     server processes can work in parallel on transactions sent to a shared message queue.

     Before a process can send or receive a message, the queue must be initialized (through the msgget 
     function) Operations to send and receive messages are performed by the msgsnd() and msgrcv() 
     functions, respectively.
  </Answer>
</QA>
<QA ID="141" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     which functions do unix programming message queue provide ?
  </Question>
  <Answer>
     They allow two or more processes to exchange information
  </Answer>
</QA>
<QA ID="142" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Please give example of key word &quot;using&quot; in c++11
  </Question>
  <Answer>
     using for type alias:
       usage: using identifier attr(optional) = type-id 
       example:

		// type alias, identical to
		// typedef void (*func)(int, int);

		using func = void (*) (int, int);

		void example(int, int) {}
		func f = example;

  </Answer>
</QA>

<QA ID="143" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     What is inode ?
  </Question>
  <Answer>
     The inode is a data structure that describes a filesystem object 
     such as a file or a directory. Each inode stores the attributes 
     and disk block location(s) of the object's data. 
     A directory contains (in its inode table) an entry for itself, 
     its parent, and each of its children.
  </Answer>
</QA>


<QA ID="144" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     What is inode number ?
  </Question>
  <Answer>
     An inode is an entry in inode table, containing information ( the metadata ) 
     about a regular file and directory

     Inode number also called index number, it consists following attributes.

     1: File types ( executable, block special etc )
     2: Permissions ( read, write etc )
     3: UID ( Owner )
     4: GID ( Group )
     5: FileSize
     6: Time stamps, including last access, last modification and last inode number change.
     7: File deletion time
     8: Number of links ( soft/hard )
     9: Location of File on harddisk.
     10:Some other metadata about file.

     to check inode number of file, use following command. The first field is inode number:

     $ls -il readme.txt
      1150561 -rw-r--r-- 1 root root 0 Mar 10 01:06 tecadmin.txt

     you can search for a file by inode number using find:

     $find -inum 1150561 
     ./readme.txt

     move and rename does not change the inode number (within one file system),  they only change
     the time stamps in inode table (a table for a directory for all its files, subdirs,parent dirs)
  </Answer>
</QA>

<QA ID="145" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     what is hardlink ?
  </Question>
  <Answer>
     A hard link is just an additional name for an existing file 
     Hard links can also be created to other hard links. Any number 
     of hard links, and thus any number of names, can be created for 
     any file. Hard links can also be created to other hard links. 
     However, they cannot be created for directories, and they cannot 
     cross filesystem boundaries or span across partitions

     Perhaps the most useful application for hard links is to allow 
     files, programs and scripts to be easily accessed in a different 
     directory from the original file or executable file. Typing the 
     name of the hard link will cause the program or script to be 
     executed in the same way as using its original name.
   
     use the command ln to create a hard link:
     $ln file1 hlink1 

     Example:

     $ ln aaa opennote
     $ ls -l
                 number of hlinks
                    |
	total 48K   V
	-rwxr-xr-x  2 yali.zhu None  748 Jun 20 14:55 aaa*
	drwxr-xr-x+ 1 yali.zhu None    0 Jun 17 23:52 bin/
	drwxr-xr-x+ 1 yali.zhu None    0 Jun 22 11:51 boostNote/
	drwxr-xr-x+ 1 yali.zhu None    0 Jun 20 14:56 C++Review/
	-rw-r--r--  1 yali.zhu None  177 Jun 18 12:06 commandsUsed.txt
	-rwxr-xr-x  1 yali.zhu None 6.1K Jun 21 12:29 JobSearch2018.txt*
	-rwxr-xr-x  2 yali.zhu None  748 Jun 20 14:55 opennote*
	-rwxr-xr-x  1 yali.zhu None  143 May 23 16:40 processChanges*
	-rwxr-xr-x  1 yali.zhu None  142 Jun  4 13:30 processChanges2*
	-rwxr-xr-x  1 yali.zhu None  144 Jun  4 13:32 processChanges2.bash*
	drwxr-xr-x+ 1 yali.zhu None    0 Jun  1 00:26 projects/
	drwxr-xr-x+ 1 yali.zhu None    0 Jun 19 23:21 yalishare/
	drwxr-xr-x+ 1 yali.zhu None    0 Jun 21 13:25 YaliSources/

        $ ls -il aaa opennote
        56013520365968768 -rwxr-xr-x 2 yali.zhu None 748 Jun 20 14:55 aaa*
        56013520365968768 -rwxr-xr-x 2 yali.zhu None 748 Jun 20 14:55 opennote*   //inode number is the same as aaa above

        $ find -inum 56013520365968768
        ./aaa
        ./opennote


  </Answer>
</QA>

<QA ID="146" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     what is softlink ?
  </Question>
  <Answer>
     A symbolic link, also termed a soft link, is a special kind 
     of file that points to another file, much like a shortcut in 
     Windows or a Macintosh alias. Unlike a hard link, a symbolic 
     link does not contain the data in the target file. It simply 
     points to another file(entry) somewhere in the file system.
     And it can cross filesystem boundaries

     Soft links is a special kind of file that points to another 
     file, much like a shortcut. Unlike a hard link, a symbolic 
     link does not contain the data in the target file. It simply 
     points to another entry somewhere in the file system. 

     To create a soft link:
     ln -s file linkname
     
     example:

     $ ln -s aaa opennoteSoft
     $ ls -il aaa open*
                       l in this column shows it is a softlink
                        |                                   Arrow shows where the soft link point to
                        V                                                         |
      56013520365968768 -rwxr-xr-x 2 yali.zhu None 748 Jun 20 14:55 aaa*          | 
      56013520365968768 -rwxr-xr-x 2 yali.zhu None 748 Jun 20 14:55 opennote*     v
      60517119993349091 lrwxrwxrwx 1 yali.zhu None   3 Jun 22 15:58 opennoteSoft -> aaa*    

  </Answer>
</QA>

<QA ID="147" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is difference between hardlink and soft link ?
  </Question>
  <Answer>
     This difference gives symbolic links certain qualities that 
     hard links do not have, such as the ability to link to directories, 
     or to files on remote computers networked through NFS. Also, when 
     you delete a target file, symbolic links to that file become unusable, 
     whereas hard links preserve the contents of the file. 

	inode &lt;--------
	   ^          |
	   |          | 
	myHardLink  myfile.txt &lt;----------  mySoftLink
  </Answer>
</QA>

<QA ID="148" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is a file descriptor ?
  </Question>
  <Answer>
     File descriptor is an abstract indicator used to access a file or other IO resource, 
     such as a file or network socket. It forms a part of the POSIX API. 
     A file descriptor is a non-negative integer and in C language, it is an integer.
     POSIX has 3 standard file descriptors:
   
     stdio.h file stream    Integer Value
     ------------------------------------
     stdin                    0
     stdout                   1
     stderror                 2
     ------------------------------------
  </Answer>
</QA>

<QA ID="149" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What does aka mean as in aka Unix Platform ?
  </Question>
  <Answer>
     aka is a short form of Also Known As. So, you would know this:
     Linux, aka Unix Platform, ...
   
  </Answer>
</QA>

<QA ID="150" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     What is process control block in Linux ?
  </Question>
  <Answer>
     Process Control Block (PCB, also called Task Controlling Block, Entry of 
     the Process Table, Task Struct, or Switchframe) is a data structure in 
     the operating system kernel containing the information needed to manage 
     the scheduling of a particular process
  </Answer>
</QA>

<QA ID="151" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     What is process table in Linux ?
  </Question>
  <Answer>
     Process table is a data structure in Linux kernel, which store information 
     about all currently running process. The process table contains process ID's, 
     memory usage of the process, all the file descriptors used in the process, etc.
  </Answer>
</QA>

<QA ID="152" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     What command to use to change file access permission ?
  </Question>
  <Answer>
     chmod
  </Answer>
</QA>

<QA ID="153" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     Where is shell located on linux system ?
  </Question>
  <Answer>
     $ echo $SHELL
     /bin/csh

  </Answer>
</QA>

<QA ID="154" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     What is a shell ?
  </Question>
  <Answer>
     The shell is a program that takes commands from the keyboard and gives them 
     to the operating system to perform.
  </Answer>
</QA>

<QA ID="155" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     What are the a few most popular shells nowadays ?
  </Question>
  <Answer>
     1: bash - GNU Bourne A-gain SHell
     2: ksh  - Korn Shell
     3: Zsh
     4: Fish - friendly interactive shell
     5: Tcsh / Csh, enhanced C shell, C like syntax

  </Answer>
</QA>

<QA ID="156" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     What does the export command do ?
  </Question>
  <Answer>
     We need to export the variable for it to be inherited by another program 
     - including a shell script
  </Answer>
</QA>

<QA ID="157" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     What are frequent use shell variables ?
  </Question>
  <Answer>
     Shell variables are usually named in uppercase.Most frequeltly used are:
     1. SHELL
     2. HOSTNAME
     3. HISTFILE
     4. HOME
     5. LOGONSERVER
     6. NUMBER_OF_PROCESSORS
     7. OS
     8. PWD
     9. TERM
     10. USERNAME
     11. USERDOMAIN
  </Answer>
</QA>

<QA ID="158" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     What does the finger command do ?
  </Question>
  <Answer>
     Finger may be used to look up users on a remote machine.
     It displays information about a user on a specified system running the
     finger service. Output varies based on the remote system.
  </Answer>
</QA>

<QA ID="159" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     What does the logname command do ?
  </Question>
  <Answer>
     logname (stands for Login Name) is a program in Unix and Unix-like 
     operating systems that prints the name of the user executing the command.
  </Answer>
</QA>

<QA ID="160" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is Camel case in naming convension?
  </Question>
  <Answer>
     Camel case is the practice of writing compound words or phrases such that 
     each word or abbreviation in the middle of the phrase begins with a 
     capital letter, with no intervening spaces or punctuation.

     Example:
        thisIsAmerica, getProperties etc

     But Pascal Case is similar, with first letter capitalized:
        ThisIsAmerica, GetProperties etc
  </Answer>
</QA>

<QA ID="161" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is CGI ?
  </Question>
  <Answer>
     Common Gateway Interface
  </Answer>
</QA>

<QA ID="162" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     In Perl, all variables start with what ?
  </Question>
  <Answer>
     with $, like $abc, is a variable
     All variables are marked with leading sigils in perl script
  </Answer>
</QA>
<QA ID="163" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     In what areas is Perl used for ?
  </Question>
  <Answer>
     In addition to CGI, Perl 5 is used for system administration, network 
     programming, finance, bioinformatics, and other applications, such as 
     for GUIs, because of its flexibility and power.

     GUIs may be developed using Perl. For example, Perl/Tk and wxPerl are 
     commonly used to enable user interaction with Perl scripts. Such 
     interaction may be synchronous or asynchronous, using callbacks to 
     update the GUI.

  </Answer>
</QA>

<QA ID="164" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Who is going to interview me on June 25 ?
  </Question>
  <Answer>
     Who to ask for: Chad Komer or Jason Walston
  </Answer>
</QA>

<QA ID="165" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     What does top command do ?
  </Question>
  <Answer>
     top command displays processor activity of your Linux box and also 
     displays tasks managed by kernel in real-time. It'll show processor 
     and memory are being used and other information like running processes. 
     This may help you to take correct action. top command found in 
     UNIX-like operating systems.
  </Answer>
</QA>

<QA ID="166" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     which command
  </Question>
  <Answer>
     which is a Unix command used to identify the location of executables. 
     The command takes one or more arguments; for each of these arguments, 
     it prints the full path of the executable to stdout that would have 
     been executed if this argument had been entered into the shell
  </Answer>
</QA>

<QA ID="167" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     who command ?
  </Question>
  <Answer>
     The standard Unix command who displays a list of users who are 
     currently logged into the computer. The who command is related to 
     the command w , which provides the same information but also 
     displays additional data and statistics.
  </Answer>
</QA>

<QA ID="168" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     w command ?
  </Question>
  <Answer>
     The command w on many Unix-like operating systems provides a quick 
     summary of every user logged into a computer, what each user is 
     currently doing, and what load all the activity is imposing on the 
     computer itself. The command is a one-command combination of several 
     other Unix programs: who, uptime, and ps -a.

     example:

     $ w
        11:12am up 608 day(s), 19:56,  6 users,  load average: 0.36, 0.36, 0.37
     	User     tty       login@  idle  what
	smithj   pts/5      8:52am       w
	jonesm   pts/23    20Apr06    28 -bash
	harry    pts/18     9:01am     9 pine
	peterb   pts/19    21Apr06       emacs -nw html/index.html
	janetmcq pts/8     10:12am 3days -csh
	singh    pts/12    16Apr06  5:29 /usr/bin/perl -w perl/test/program.pl
  </Answer>
</QA>

<QA ID="169" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     source command  ?
  </Question>
  <Answer>
     The source command can be used to load any functions file into the 
     current shell script or a command prompt. It read and execute commands 
     from given FILENAME and return.
    
     The source command can be abbreviated as just a dot (.) in Bash and 
     similar POSIX-ish shells. 
  </Answer>
</QA>

<QA ID="170" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     tar command ?
  </Question>
  <Answer>
     The Linux &quot;tar&quot; stands for tape archive, which is used by large number 
     of Linux/Unix system administrators to deal with tape drives backup. 
     The tar command used to rip a collection of files and directories into 
     highly compressed archive file commonly called tarball or tar, gzip 
     and bzip in Linux
  </Answer>
</QA>

<QA ID="171" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     ifconfig command ?
  </Question>
  <Answer>
     ifconfig is a system administration utility in Unix-like operating 
     systems for network interface configuration. The utility is a command 
     line interface tool and is also used in the system startup scripts of 
     many operating systems.
  </Answer>
</QA>

<QA ID="172" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     How to use boost library lexical cast ?
  </Question>
  <Answer>
     lexical cast makes type conversion so much easier.
   1: #include "boost/lexical_cast.hpp"
   2: using boost::lexical_cast;
   3: using boost::bad_lexical_cast;
   4: ready to use it: convert an integer to string:
       int s=123;
       string str0=lexical_cast&lt;string&gt;(s);
       string str1=lexical_cast&lt;string&gt;(2.3);
       string str2=lexical_cast&lt;string&gt;('A');
       array&lt;char,64&gt; msg=lexical_cast&lt;array&lt;char,64&gt;&gt;(23);   //array with specific size is a type

       try {
          s=lexical_cast&lt;int&gt;("56.78");
       }catch(bad_lexical_cast &e}{
          cout &lt;&lt; e.what() &lt;&lt; endl;
       }

       s=lexical_cast&lt;int&gt;("5678yu");    //bad_lexical_cast
       s=lexical_cast&lt;int&gt;("5678yu",4);  //good

  </Answer>
</QA>

<QA ID="173" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     How to use boost library variant ?
  </Question>
  <Answer>
     boost variant to solve the traditional problem:
         union{int i; float f;} u;   //good:
         union{int i; string f;} u;  //bad
     usage:
     1: #include "boot\variant.hpp"
     2: declaration: 
         boost::variant&lt;int,string&gt; u1,u1;    //boost's way of union
         u1=2;
         u2="hello";
         u1=boost::get&lt;int&gt;(u1)*2;      //has to use get to change u1 to a number ?
         string st=boost::get&lt;string&gt;(u1);     //bad get
                st=boost::get&lt;string&gt;(u2);     //good get

         boost::variant &lt;int,string&gt; u3; //u3 is 0 now until you assign a number or a string

        //then how to know v's type ?
        void Double(boost:variant&lt;int, string&gt; v);

        //solution: using boost visitor template boost::static_visitor&lt;&gt;

        class DoubleVisitor : public boost::static_visitor&lt;&gt;{
        public:
           void operator()(int &1) cont{
               i+=i;
           }
           void operator()(string & str){
               str+=str;
           }
        };

        u1=2;

        boost::apply_visitor(DoubleVisitor(),u1);   //like creating a thread, passing argument 
                                                    //in second position, result: u1 becomes 4
        u2="hello";

        boost::apply_visitor(DoubleVisitor(),u2);   // u2 becomes "HelloHello"

        //visitor is like polymorphism on variant

        std::vector&lt;boost::variant&lt;int,string&gt;&gt; vec;
        vec.push_back("good");
        vec.push_back(23);
        vec.push_back("bad");
        DoubleVisitor f;
        for(auto x: vec){
           boost::apply_visitor(f,x);
        }

        //Note variant can never be empty, but any can be empty
  </Answer>
</QA>

<QA ID="174" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     How to use boost any ?
  </Question>
  <Answer>
     #include "boost\any.hpp"

     void main(){
        boost::any x,y,z;
        x=string("hello");
        x=2.3;
        y='z';
        z=vector&lt;int&gt;();
        //all these uses heap, dynamic storage
        //variant use stack storage, so more efficient;
   
        //to print any:
        cout &lt;&lt; boost::any_cast&lt;char&gt;(y) &lt;&lt;endl;  //return a copy of y's data 'z'
        cout &lt;&lt; boost::any_cast&lt;double&gt;(x) &lt;&lt;endl;  //return a copy of y's data 'z'
        cout &lt;&lt; boost::any_cast&lt;int&gt;(x) &lt;&lt; endl;  //throws exception: bad_any_cast
        cout &lt;&lt; boost::any_cast&lt;float&gt;(x) &lt;&lt; endl;  //throws exception: bad_any_cast: 
                                                    //must match exact type !        
        boost::any_cast&lt;vector&lt;int&gt;&gt;(z).push_back(23);   //this actually returns a copy 
                                                   //of the vector stored in z. so, 
                                                   //this line doesn't do anything meaningful
        int i=boost::any_cast&lt;vector&lt;int&gt;&gt;(z).push_back();  //crash because z is still 
                                                            // holding an empty vector!
        //back() Returns a reference to the last element in the vector.
   
        //store pointers:
        int i=5;
        boost::any p=&i;
        int * pInt=boost::any_cast&lt;int*&gt;(p);
   
        //as a class:
        vector&lt;boost:any&gt; m;
        m.push_back(2);
        m.push_back('a');
        m.push_back(p);
        m.push_back(boost::any());    //a place holder
   
        //for store property settings
        struct Property{
           string name;
           boost::any value;
        };
        vector&lt;Property&gt; properties;
   
        //any can be empty:
        if(x.empty())
           cout &lt;&lt; "x is empty " &lt;&lt; endl;
	
     	//type can be checked only at runtime:
	if(x.type() == typeid(char))
	   cout &lt;&lt; "x is a char" &lt;&lt; endl;
   
     }


Note: boost::any's datatype can only be checked at runtime
  </Answer>
</QA>

<QA ID="175" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Boost Library ?
  </Question>
  <Answer>
     Boost is a set of libraries for the C++ programming language that provide support for tasks 
and structures such as linear algebra, pseudorandom number generation, multithreading, image processing, 
regular expressions, and unit testing. It contains over eighty individual libraries.

Most of the Boost libraries are licensed under the Boost Software License, designed to allow Boost to 
be used with both free and proprietary software projects. Many of Boost's founders are on the C++ standards 
committee, and several Boost libraries have been accepted for incorporation into both the C++ Technical 
Report 1 and the C++11 standard.

The libraries are aimed at a wide range of C++ users and application domains. They range from general-purpose 
libraries like the smart pointer library, to operating system abstractions like Boost FileSystem, to libraries 
primarily aimed at other library developers and advanced C++ users, like the template metaprogramming (MPL) 
and domain-specific language (DSL) creation (Proto).

In order to ensure efficiency and flexibility, Boost makes extensive use of templates. Boost has been a source 
of extensive work and research into generic programming and metaprogramming in C++.

Most Boost libraries are header based, consisting of inline functions and templates, and as such do not need 
to be built in advance of their use. Some Boost libraries coexist as independent libraries.
  </Answer>
</QA>

<QA ID="176" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Boost smart pointer ?
  </Question>
  <Answer>
    Smart pointers
     1.Scoped pointer: scoped_ptr

	#include &lt;boost/scoped_ptr.hpp&gt;

        struct Object{
           int value;
        }
        void main(){
	   boost::scoped_ptr&lt;int&gt; int_ptr(new int);   //delete itself when go out scope
           int_ptr.reset(new int);                    //
	
           boost::scoped_ptr&lt;Object&gt; ptr;
	   if(ptr) {
	    //do something here. but ptr is null now, so it won't come in here
	   }
	
	   ptr.reset(new Object);
	   if(ptr){
	     Object object=*ptr;
		ptr-&gt;value=5;
	   }
        }      
        //scope pointers 
        1)cannot copy
        2)cannot use STL containers 
        3)can swap with another scoped_ptr
        4)can resest

   2. shared pointer:

        #include &lt;boost/shared_ptr.hpp&gt;
        void main(){
           boost::shared_ptr&lt;int&gt; int_ptr(new int);
           Owner a(int_ptr);
           Owner b(int_ptr);
           Owner c(int_ptr);
           //no need to delete here anymore
           //you can copy it, can use with STL containers
        }
  </Answer>
</QA>

<QA ID="177" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     STL smart pointers
  </Question>
  <Answer>
     They are all class tempate:

	template&lt;class T&gt;
	std:shared_ptr&lt;T&gt;
	std:unique_ptr&lt;T&gt;
	std:weak_ptr&lt;T&gt;

	tempalte&lt;class T&gt;
	class weak_ptr;

	//less perfect way to create a shared pointer
	shared_ptr&lt;Dog&gt; p(new Dog("Gunner"));

	//prefered way to create a shared pointer:
	shared_ptr&lt;Dog&gt; p=make_shared&lt;Dog&gt;("Tank");

	shared poitner casting:
	//function tempalte for casting
	static_pointer_cast&lt;T&gt;
	dynamic_pointer_cast&lt;T&gt;
	const_poitner_cast&lt;T&gt;

	example:
	foo = std::dynamic_pointer_cast&lt;A&gt;(bar);

	//unique_ptr functions

	release()
	reset()
  </Answer>
</QA>

<QA ID="178" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Which one is the default c language pre-precessor on most standard Unix systems?

	a: gcc
	b: g77
	c: g++
	d: cpp
	e: php
  </Question>
  <Answer>
     Answer: cpp, short for c pre-precessor
  </Answer>
</QA>

<QA ID="179" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     In the X window system, which of the following is true about the windows manager?

	A: It is a client application that maintains the "look and feel" 
           of other client application's windows
	B: It is the same as the X server
	C: It must run on the same machine as the X server.
  </Question>
  <Answer>
     Answer is A
  </Answer>
</QA>
<QA ID="180" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Why is fgets superior to gets?

	A: fgets uses I/O buffering for improved efficiency
	B: fgets takes a size parameter which is used to prevent buffer overflow
	C: fgets does type conversion
  </Question>
  <Answer>
     Answer is B
  </Answer>
</QA>
<QA ID="181" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What will happen when the following code is run ?
        int x;
	while (x &lt; 100) {
		cout &lt;&lt; x++;
	}

        A: The computer will output like 0123...99
        B: The computer will output 0123...100
        C: The output is undefined
        D: None of the above
  </Question>
  <Answer>
     when compile, got error C4700: uninitialized local variable 'x' used
     The error is compiler dependent. Correct answer should be undefined for 
     uninitialized local variable x

  </Answer>
</QA>
<QA ID="182" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     A relational operator is used to 
     A: combine values
     B: compare values
     C: distinguish different types of variables
     D: change variables to local values
  </Question>
  <Answer>
     B
  </Answer>
</QA>
<QA ID="183" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What does 7/9*9 equal to (in C and C++) ?
  </Question>
  <Answer>
     0
  </Answer>
</QA>
<QA ID="184" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Variables with names that describe the data stored at that particular memory location are called
     
     A: identifiers
     B: constant variables
     C: floating point variables
     D: mnemonic variables
  </Question>     
  <Answer>
     D
  </Answer>
</QA>
<QA ID="185" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     pushdown list means: 
     
     A: Stack
     B: Queue
     C: Linked List
     D: All of the ablove
  </Question>
  <Answer>
     A.  Push-down list - a list in which the next item to be removed is the item most recently stored (LIFO)
  </Answer>
</QA>
<QA ID="186" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     When must template functions have explicit template parameters ?

     A: always
     B: When the template types cannot be infered
     C: Never. The template types can always be inferred.
  </Question>
  <Answer>
     B
  </Answer>
</QA>
<QA ID="187" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     When are templates usually instantiated ?
     A: At runtime
     B: At compile time
     C: At link time
  </Question>
  <Answer>
     B
  </Answer>
</QA>
<QA ID="188" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Are templates conceptually related to polymorphism ?
     
     A: Nope
     B: Only when the template types are objects
     C: Yes, but compile-time polymorphism
  </Question>
  <Answer>
     C
  </Answer>
</QA>
<QA ID="189" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     In general, is it possible to completely hide the source code of a library written using templates ?

     A: Yes, but using export feature
     B: No, pretty much never
     C: Yes, all the time
  </Question>
  <Answer>
     B
  </Answer>
</QA>
<QA ID="190" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Which of the following describes a potentially surprising result of using templates ?

     A: Slower programs
     B: Poor variable naming in the debugger
     C: Increased executable size in comparison to the code base
  </Question>
  <Answer>
     C
  </Answer>
</QA>
<QA ID="191" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Following declarations are the same ?
       const char *s;
       char const *s;

  </Question>
  <Answer>
     True
  </Answer>
</QA>
<QA ID="192" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     When will this line fail to compile: new myObj[100]; ?
    
     A: Never
     B: when myObj is too large to fit into memory
     C: When myObj has no default constructor
  </Question>    
  <Answer>
     C

      When you have alternate constructor, the compiler will not generate a default constructor for you.
  </Answer>
</QA>
<QA ID="193" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is wrong with the following code ?

      int *x=(int*)malloc(100*sizeof(int));
      x=realloc(x,sizeof(int)*200);

      A: If realloc fails, then the original memory is lost
      B: Nothing, realloc is guaranteed to succeed (by returnning the original pointer)       
      C: Nothing, realloc frees the original memory passed to it

  </Question>
  <Answer>
      A
  </Answer>
</QA>
<QA ID="194" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is one possible symptom of having called free on the same block of memory twice ?

     A: Nothing, calling free twice on one block of memory always works fine
     B: Malloc might always return the same block of memory
     C: You cannot free any memory in the future
  </Question>
  <Answer>
     B.  
  </Answer>
</QA>
<QA ID="195" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Assuming this code were being compiled using a standards-conforming C++, what is wrong with it ?

     int *x = malloc(100*sizeof(int));
     x = realloc(x,sizeof(int));

     A: malloc is undefined in C++, you can only allocate memory using new
     B: Invalid cast from a void * to an int*
     C: Nothing is wrong with this code
  </Question>
  <Answer>
     B
  </Answer>
</QA>
<QA ID="196" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is a difficulty that arises with handling out of memory errors ?

     A: Many cleanup operations require extra memory
     B: Running out of memory rarely happens in systems that interact with users
     C: Once you have run out of memory, your program cannot continue
  </Question>
  <Answer>
     A
  </Answer>
</QA>
<QA ID="197" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is wrong with this line of code ?

     delete NULL;

     A: It causes a segmentation fault when delete trires to access NULL;
     B: Nothing
     C: It is undefined behavior
  </Question>
  <Answer>
     B
  </Answer>
</QA>
<QA ID="198" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Unions can contain most types in their member lists, except for 3 cases, which are what?
  </Question>
  <Answer>
     1. Class types that have constructors or destructors
     2. Class types that have user-defined assignment operators
     3. Static data members
  </Answer>
</QA>
<QA ID="199" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Can the anonymouse unions have function members ?
  </Question>
  <Answer>
     No
  </Answer>
</QA>
<QA ID="200" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Can you overload the constructor ?
  </Question>
  <Answer>
     Yes
  </Answer>
</QA>
<QA ID="201" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is a generic class ?
  </Question>
  <Answer>
     asf
  </Answer>
</QA>

</QuestionsAndAnswers>