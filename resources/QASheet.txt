<?xml version="1.0"?>
<!DOCTYPE QR SYSTEM "QuickReview.dtd">

<QuestionsAndAnswers>

<QA ID="1" type="OneAnswer" category="CPP" countdown="0" resetto="0" >

  <Question>
        How can I handle a constructor that fails ?
  </Question>

  <Answer>
     throw an exception. Constructors don't have a return type, so it's not possible to use return codes. The best way to signal constructor failure is therefore to throw an exception.
  </Answer>
</QA>


<QA ID="2" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is difference between process and thread ?
  </Question>
  <Answer>
      A process provides the resources needed to execute a program. A process has:
        - a virtual address space, 
        - executable code, 
        - open handles to system objects, 
        - a security context,          - process identifier, 
        - environment variables, 
        - at least one thread of execution ( Each process is started with a single thread, often called the primary thread, but can create additional threads from any of its threads.)

      A thread is the entity within a process that can be scheduled for execution. 
        - All threads of a process share its:
           - virtual address space and 
           - system resources. 
        - each thread maintains 
           - exception handlers, 
           - a scheduling priority, 
           - thread local storage, 
           - a unique thread identifier, 
           - a set of structures the system use to save the thread context until it is scheduled. 
           - each thread context includes :
              - the thread's set of machine registers, 
              - the kernel stack, 
              - a thread environment block, 
              - a user stack in the address space of the thread's process. 
              - a security context, which can be used for impersonating clients.
  </Answer>
</QA>
<QA ID="3" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      Difference between Lock and control variable ?
  </Question>
  <Answer>
        ??
  </Answer>
</QA>
<QA ID="4" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      Difference between mutex and semorephone ?
  </Question>
  <Answer>
      A mutex can be owned by only one thread at a time, enabling threads to coordinate mutually exclusive access to a shared resource.
      A semaphore maintains a count between zero and some maximum value, limiting the number of threads that are simultaneously accessing a shared resource.
  </Answer>
</QA>
<QA ID="5" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is Unique pointer and what is the diffrence between unique pointer and shared pointer?
  </Question>
  <Answer>
      Unique pointer and Shared pointer are all smart pointers. Unique pointer means an object can only be pointered by one pointer
      shared poitners keeps a count on number of pointers to an object and when the count drops to 0, the object is destroied !
  </Answer>
</QA>
<QA ID="6" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is weak poitner?
  </Question>
  <Answer>
      Weak pointer is a kind of pointer that does not own the object, does not affect the pointer count!
  </Answer>
</QA>
<QA ID="7" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is vector?
  </Question>
  <Answer>
    A vector is a dynamic array that can only grow in one direction, and is contiguously allocated in memory.

   vector pros and cons:
   - fast insert/remove at the end: O(1)
   - slow insert/remove at the begining and middle: O(n)
   - slow search (linear time): O(n)
   - random access
  </Answer>
</QA>

<QA ID="8" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is deque ?
  </Question>
  <Answer>
      A deque is a dynamic array that can grow in both directions, and is contiguously allocated in memory.
  </Answer>
</QA>

<QA ID="9" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is array and what is its pros and cons ?
  </Question>
  <Answer>
      array is fixed in size! and different size makes them different types.
  </Answer>
</QA>
<QA ID="10" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is the difference between list and forward list ?
  </Question>
  <Answer>
      list is a doubly-linked list. Forward list is a singly-linked list
  </Answer>
</QA>
<QA ID="11" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is weak poitner?
  </Question>
  <Answer>
      Weak pointer is a kind of pointer that does not own the object, does not affect the pointer count!
  </Answer>
</QA>
<QA ID="12" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What are STL Containers
  </Question>
  <Answer>
   STL Containers can be divieded into 3 categories:
   1) Sequence Containers (Array and linked list)
       - vector
       - deque
       - list
       - forward list
       - array
   2) Associative Containers (binary tree)
       - set, multiset,
       - map, multimap
   3) Unordered Containers (hash table)
       - Unordered set/multiset;
       - Unordered map/multimap

   its headers to include: 
        - &lt;vector&gt;
        - &lt;deque&gt;
        - &lt;list&gt;
        - &lt;set&gt;
        - &lt;map&gt;
        - &lt;unordered_set&gt;
        - &lt;unordered_map&gt;

   other STL includes:
        - &lt;iterator&gt;
        - &lt;algorithm&gt;
        - &lt;numeric&gt;     
        - &lt;functional&gt;  //for functors

   methods shared across all containers:
   - empty()   //check for empty
   - size()
   - clear()   //remove all elements
   - swap(T)   //swap all elements
  </Answer>
</QA>
<QA ID="13" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is associate containers ?
  </Question>
  <Answer>
      Associate containers refer to map/multimap and set/multiset.
      Associate means keys are associated with values
      For set/map, the keys can be considered the same as values
      - They are always sorted, so no push_front(), push_back() methods
      - They are implemented as binary tree.
      - They are fast in search
      - They are slow in traversing
      - No Random acces, no [] operator
      - Elements (keys) can't be modified
  </Answer>
</QA>
<QA ID="14" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      show some set snippets:
  </Question>
  <Answer>

  snippet:

    set&lt;int&gt; myset;
    myset.insert(3);
    myset.insert(1);
    myset.insert(7);         //myset: {1,3,7}

    set&lt;int&gt;::iterator it;
    it=myset.find(7);       //fast, sequence containers do not have find() memeber function
                            //fast O(log(n))   &lt;=====outstanding feature
    pair&lt;set&lt;int&gt;::iterator, bool&gt; set;
    ret=myset.insert(3);    //no new element inserted, because no duplicates allowed
    if(ret.second==false)   //return a pair of values: ret.first, ret.second
      it=ret.first;         //"it" now points to element 3
     
    myset.insert(it,9);     //hint where it is pointing to, {1,3,7,9}
    myset.erase(it);        //myset: {1,7,9}
    myset.erase(7);         //myset: {1,9}
   
  </Answer>
</QA>
<QA ID="15" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      what is difference between set and muti set ?
  </Question>
  <Answer>
      Difference is that muti set allows duplcates while set does not allow duplicates
      Difference between map and multimap is multimap allows duplicate keys
  </Answer>
</QA>
<QA ID="16" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is the difference between set/multiset and map/multimap ?
  </Question>
  <Answer>
      Map/multimap is just a key-value paired version of set/multiset.
  </Answer>
</QA>
<QA ID="17" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What about unordered containers ? what are unordered containers and what are their pros and cons
  </Question>
  <Answer>
      Unordered set/multiset, map/multimap are unordered containers
      they are implemented as hash tables 
      has following features:
        -fast search O(1)
        -fast insert O(1)
        -element value can't be changed for unordered set/multiset
        -element key can't be change for unordered map/multimap

      snippet:
        unordered_set&lt;string&gt; = { "red", "green", "blue" };
        unordered_set&lt;string&gt;::const_iterator itr =  myset.find("green");  //fast, O(1)
        if(itr != myset.end())   //need to check if found
          cout &lt;&lt; *itr &lt;&lt; endl;
        myset.insert("yellow");   // O(1), fast

        vector&lt;string&gt; vec={"purple","pink"};    //an vector to be inserted into myset
        myset.insert(vec.begin(), vec.end());    //insert a vector into a set 

        //Hash table APIs: load_factor(),bucket(),bucket_count()
        cout &lt;&lt; "load_factor="&lt;&lt; myset.load_factor() &lt;&lt; endl;
        string x = "red";
        cout &lt;&lt; x &lt;&lt; " is in buket #" &lt;&lt; myset.bucket(x) &lt;&lt; endl;
        cout &lt;&lt; "Total bucket #=" &lt;&lt; myset.bucket_count() &lt;&lt; endl;

  </Answer>
</QA>
<QA ID="18" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is Associate Array?
  </Question>
  <Answer>
      Associate Array is map and unordered map. They are Associate Containers with [] operators.
      
      Following snippet shows its usages:
       
      unordered_map&lt;char, string&gt; day={{'S',"Sunday"},{'M',"Monday"}};

      cout &lt;&lt; day['S']    &lt;&lt; endl;    //No  range check
      cout &lt;&lt; day.at('S') &lt;&lt; endl;    //Has range check

      vector&lt;int&gt; vec={1,2,3};
      vec[5]=5;                             // compile Error: out of range

      day['W'] = "Wednesday";               //OK, inserting {'W',"Wednesday'}
      day.insert(make_pair('F',"FRIDAY"));  //inserting, same as above

      day.insert(make_pair('M',"MONDAY));   //Already exist for M, failed
      day['M'] = "MONDAY";                  //Succeeded modifying: [] operator has write access

      //Effect of [] operator's write access:
      void foo (const unordered_map&lt;char, string&gt; &#38; m ) { //param m is const reference
         m['S'] = "SUNDAY";                  //compile error, write access
         cout &lt;&lt; m['S'] &lt;&lt; endl;            //compile error too for print access, which is write access writing this way
         auto itr = m.find('S');
         if(itr !=m.end())
           cout &lt;&lt; itr-&gt;second &lt;&lt;endl;       //compile OK, no write access !
      }

      foo(day);

      //so, use map or unordered map ? here are the factors to consider:
      // Associate array: map and unordered_map only:
      1 search O(1): unordered_map =&gt; may degrade to O(n)
          O(log(n)): map =&gt; garanteed O(log(n)) search time
      2 Can't use multimap and unordered_multimap:
          they do not have [] operator, so can't be used as an array
  </Answer>
</QA>

<QA ID="19" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is Container Adapter ?
  </Question>
  <Answer>
      Container Adapter provide restricted interface to underlying containers to meet special needs
      they are implemetned with fundamental container classes. There are 3:
      1. stack: LIFO: push(), Pop(), top()
      2. queue: FIFO: push(), pop(), front, back()
      3. priority queue: first item always has the greatest priority
                push(), pop(), top() 
      
  </Answer>
</QA>

<QA ID="xxx" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is weak poitner?
  </Question>
  <Answer>
      Weak pointer is a kind of pointer that does not own the object, does not affect the pointer count!
  </Answer>
</QA>

</QuestionsAndAnswers>