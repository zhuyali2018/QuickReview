      <?xml version="1.0"?>
<!DOCTYPE QR SYSTEM "QuickReview.dtd">

<QuestionsAndAnswers>
<QA ID="0" type="OneAnswer" category="CPP" countdown="0" resetto="0" >

  <Question>
     How can I handle a constructor that fails ?
  </Question>

  <Answer>
     By throwing an exception. Constructors don't have a return type, so it's not possible to use
     return codes. The best way to signal constructor failure is therefore to throw an exception.
  </Answer>
</QA>

<QA ID="1" type="OneAnswer" category="CPP" countdown="0" resetto="0" >

  <Question>
     How can I handle a constructor that fails ?
  </Question>

  <Answer>
     By throwing an exception. Constructors don't have a return type, so it's not possible to use
     return codes. The best way to signal constructor failure is therefore to throw an exception.
  </Answer>
</QA>


<QA ID="2" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is difference between process and thread ?
  </Question>
  <Answer>
     The typical difference is that threads (of the same process) run in a shared memory space, 
     while processes run in separate memory spaces.
     Each thread has its own storage, stack, environment block, security context, set of registers
     exception handlers, priority. But all threads in one process share the same heap.
  </Answer>
</QA>
<QA ID="3" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What exactly is the role of Triage Engineer ?
  </Question>
  <Answer>
      This title is someone that classifies bugs for someone else to fix.
      When a bug report comes in, you mark it as duplicate if another one exists, ask for more 
      details if reproduce steps aren't clear, close it if it is not a bug, assign it to the main 
      engineer if it is a bug. Basically a issue tracker janitor.
  </Answer>
</QA>
<QA ID="4" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      Difference between mutex and semorephone ?
  </Question>
  <Answer>
    - A mutex can be owned by only one thread at a time, enabling threads to coordinate mutually 
      exclusive access to a shared resource.

    - A semaphore maintains a count between zero and some maximum value, limiting the number of 
      threads that are simultaneously accessing a shared resource.
  </Answer>
</QA>
<QA ID="5" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is Unique pointer and what is the diffrence between unique pointer and shared pointer?
  </Question>
  <Answer>
    - Unique pointer and Shared pointer are all smart pointers. Unique pointer means an object 
      can only be pointered by one pointer

    - shared pointers keeps a count on number of pointers to an object and when the count drops 
      to 0, the object is destroyed !
  </Answer>
</QA>
<QA ID="6" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is weak pointer?
  </Question>
  <Answer>
      Weak pointer is a kind of pointer that does not own the object, does not affect the pointer count!
  </Answer>
</QA>
<QA ID="7" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is vector?
  </Question>
  <Answer>
    A vector is a dynamic array that can only grow in one direction, and is contiguously allocated 
    in memory.

   vector pros and cons:
   - fast insert/remove at the end: O(1)
   - slow insert/remove at the begining and middle: O(n)
   - slow search (linear time): O(n)
   - random access
  </Answer>
</QA>

<QA ID="8" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is deque ?
  </Question>
  <Answer>
      A deque is a dynamic array that can grow in both directions, it is an indexed sequence container 
      that allows fast insertion and deletion at both its beginning and its end. In addition, insertion 
      and deletion at either end of a deque never invalidates pointers or references to the rest of 
      the elements. As opposed to std::vector, the elements of a deque are not stored contiguously: 
      typical implementations use a sequence of individually allocated fixed-size arrays, with additional 
      bookkeeping, which means indexed access to deque must perform two pointer dereferences, compared 
      to vector's indexed access which performs only one.

      The storage of a deque is automatically expanded and contracted as needed. Expansion of a deque is 
      cheaper than a std::vector because it does not involve copying of the existing elements to a new 
      memory location. On the other hand, deques typically have large minimal memory cost; a deque 
      holding just one element has to allocate its full internal array (e.g. 8 times the object size on 
      64-bit libstdc++; 16 times the object size or 4096 bytes, whichever is larger, on 64-bit libc++).

      The complexity (efficiency) of common operations on deques is as follows:

      1. Fast Random access - constant O(1)
      2. Fast Insertion or removal of elements at the end or beginning - constant O(1)
      3. Slow Insertion or removal of elements - linear O(n)
  </Answer>
</QA>

<QA ID="9" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is array and what is its pros and cons ?
  </Question>
  <Answer>
      array is fixed in size! and different size makes them different types.
  </Answer>
</QA>
<QA ID="10" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is the difference between list and forward list ?
  </Question>
  <Answer>
      list is a doubly-linked list. Forward list is a singly-linked list
  </Answer>
</QA>
<QA ID="11" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is RAII ??
  </Question>
  <Answer>
      It is Resource Acquisition is initialization.
         In RAII, holding a resource is tied to object lifetime: resource allocation
      (or acquisition) is done during object creation by the constructor, 
      while resource deallocation (release) is done during object destruction
      by the destructor.
  </Answer>
</QA>
<QA ID="12" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What are STL Containers
  </Question>
  <Answer>
   STL Containers can be divieded into 3 categories:
   1) Sequence Containers (Array and linked list)
       - vector
       - deque
       - list
       - forward list
       - array
   2) Associative Containers (binary tree)
       - set, multiset,
       - map, multimap
   3) Unordered Containers (hash table)
       - Unordered set/multiset;
       - Unordered map/multimap

   its headers to include: 
        - &lt;vector&gt;
        - &lt;deque&gt;
        - &lt;list&gt;
        - &lt;set&gt;
        - &lt;map&gt;
        - &lt;unordered_set&gt;
        - &lt;unordered_map&gt;

   other STL includes:
        - &lt;iterator&gt;
        - &lt;algorithm&gt;
        - &lt;numeric&gt;     
        - &lt;functional&gt;  //for functors

   methods shared across all containers:
   - empty()   //check for empty
   - size()
   - clear()   //remove all elements
   - swap(T)   //swap all elements
  </Answer>
</QA>
<QA ID="13" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is associate containers ?
  </Question>
  <Answer>
      Associate containers refer to map/multimap and set/multiset.
      Associate means keys are associated with values
      For set/multiset, the keys can be considered the same as values
      - They are always sorted, so no push_front(), push_back() methods
      - They are implemented as binary tree.
      - They are fast in search
      - They are slow in traversing
      - No Random acces, no [] operator
      - Elements (keys) can't be modified
  </Answer>
</QA>
<QA ID="14" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      show some set snippets:
  </Question>
  <Answer>

  snippet:

    set&lt;int&gt; myset;
    myset.insert(3);
    myset.insert(1);
    myset.insert(7);         //myset: {1,3,7}

    set&lt;int&gt;::iterator it;
    it=myset.find(7);       //fast, sequence containers do not have find() memeber function
                            //fast O(log(n))   &lt;=====outstanding feature
    pair&lt;set&lt;int&gt;::iterator, bool&gt; ret;
    ret=myset.insert(3);    //no new element inserted, because no duplicates allowed
    if(ret.second==false)   //return a pair of values: ret.first, ret.second
      it=ret.first;         //"it" now points to element 3
     
    myset.insert(it,9);     //hint where it is pointing to, {1,3,7,9}
    myset.erase(it);        //myset: {1,7,9}
    myset.erase(7);         //myset: {1,9}
   
  </Answer>
</QA>
<QA ID="15" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      what is difference between set and muti set ?
  </Question>
  <Answer>
      Difference is that multi set allows duplcates while set does not allow duplicates
      Difference between map and multimap is multimap allows duplicate keys
  </Answer>
</QA>
<QA ID="16" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is the difference between set/multiset and map/multimap ?
  </Question>
  <Answer>
      Map/multimap is just a key-value paired version of set/multiset.
  </Answer>
</QA>
<QA ID="17" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What about unordered containers ? what are unordered containers and what are their pros and cons
  </Question>
  <Answer>
      Unordered set/multiset, map/multimap are unordered containers
      they are implemented as hash tables 
      has following features:
        -fast search O(1)
        -fast insert O(1)
        -element value can't be changed for unordered set/multiset
        -element key can't be change for unordered map/multimap

      snippet:
        unordered_set&lt;string&gt; myset= { "red", "green", "blue" };
        unordered_set&lt;string&gt;::const_iterator itr =  myset.find("green");  //fast, O(1)
        if(itr != myset.end())   //need to check if found
          cout &lt;&lt; *itr &lt;&lt; endl;
        myset.insert("yellow");   // O(1), fast

        vector&lt;string&gt; vec={"purple","pink"};    //an vector to be inserted into myset
        myset.insert(vec.begin(), vec.end());    //insert a vector into a set 

        //Hash table APIs: load_factor(),bucket(),bucket_count()
        cout &lt;&lt; "load_factor="&lt;&lt; myset.load_factor() &lt;&lt; endl;
        string x = "red";
        cout &lt;&lt; x &lt;&lt; " is in buket #" &lt;&lt; myset.bucket(x) &lt;&lt; endl;
        cout &lt;&lt; "Total bucket #=" &lt;&lt; myset.bucket_count() &lt;&lt; endl;

  </Answer>
</QA>
<QA ID="18" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is Associate Array?
  </Question>
  <Answer>
      Associate Array is map and unordered map. They are Associate Containers with [] operators.
      
      Following snippet shows its usages:
       
      unordered_map&lt;char, string&gt; day={{'S',"Sunday"},{'M',"Monday"}};

      cout &lt;&lt; day['S']    &lt;&lt; endl;    //No  range check
      cout &lt;&lt; day.at('S') &lt;&lt; endl;    //Has range check

      vector&lt;int&gt; vec={1,2,3};
      vec[5]=5;                             // compile Error: out of range

      day['W'] = "Wednesday";               //OK, inserting {'W',"Wednesday'}
      day.insert(make_pair('F',"FRIDAY"));  //inserting, same as above

      day.insert(make_pair('M',"MONDAY));   //Already exist for M, failed
      day['M'] = "MONDAY";                  //Succeeded modifying: [] operator has write access

      //Effect of [] operator's write access:
      void foo (const unordered_map&lt;char, string&gt; &#38; m ) { //param m is const reference
         m['S'] = "SUNDAY";                  //compile error, write access
         cout &lt;&lt; m['S'] &lt;&lt; endl;            //compile error too for print access, which is write access writing this way
         auto itr = m.find('S');
         if(itr !=m.end())
           cout &lt;&lt; itr-&gt;second &lt;&lt;endl;       //compile OK, no write access !
      }

      foo(day);

      //so, use map or unordered map ? here are the factors to consider:
      // Associate array: map and unordered_map only:
      1 search O(1): unordered_map =&gt; may degrade to O(n)
          O(log(n)): map =&gt; garanteed O(log(n)) search time
      2 Can't use multimap and unordered_multimap:
          they do not have [] operator, so can't be used as an array
  </Answer>
</QA>

<QA ID="19" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is Container Adapter ?
  </Question>
  <Answer>
      Container Adapter provide restricted interface to underlying containers to meet special needs
      they are implemetned with fundamental container classes. There are 3:
      1. queue: FIFO:   push(), pop(), front(), back()
      2. stack: LIFO:   push(), Pop(), top()
      3. priority queue:push(), pop(), top(). First item always has the greatest priority
                 
      
  </Answer>
</QA>

<QA ID="20" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What are the 5 kinds of the iterators ?
  </Question>
  <Answer>
      1: Ramdom access iterators: vector, deque, array
      2: Bidirectional Iterators: list, set/multiset, map/multimap
      3: Forward Iterators: forward_list
      4: Input Iterator: int x = *itr; //can only move forward
      5: Output Iterator: *itr=100;    //can only move forward 

      Every container has a iterator and a const_iterator (Snippet):
      set&lt;int&gt;::iterator itr;           //RW access to container elements
      set&lt;int&gt;::const_interator citr;   //readonly access to container elements

      set&lt;int&gt; myset = {1,4,5,2,9};
      for(citr=myset.begin();citr!=myset.end();++citr){
        cout &lt;&lt; *citr &lt;&lt; endl;
        //*citr=3;   //error, citr has readonly access
      }

      for_each(myset.cbegin();myset.cend(),myfunction);   //C++11

      //iterator functions:
      advance(itr,5);          //Move itr forward by 5: itr += 5;
      distance(itr1,itr2);     //measure the distance between itr1 and itr2
  </Answer>
</QA>

<QA ID="21" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
    What is Iterator Adapter ?
  </Question>
  <Answer>
    Iterator adapters are predefined iterators, they are more powerful:

      1. Insert iterator (back_insert_iterator,front_insert_iterator)
      2. Stream iterator
      3. Reverse iterator
      4. Move iterator (c++11)

    Snippet:
      1. Insert iterator:

      vector&lt;int&gt; vec1 = {4,5};
      vector&lt;int&gt; vec2 = {13,14,16,18};
      vector&lt;int&gt;::iterator it = find(vec2.begin(),vec2.end(),16);
      insert_iterator&lt;vector&lt;int&gt;&gt; i_itr(vec2,it);
      copy(vec1.begin(),vec1,end(),i_itr);   //vec2: {12,14,4,5,16,18}
      // Other insert iterators: back-insert_iterator, front_insert_iterator

      2. Stream iterator: iterat through the data to and from a string:
         vector&lt;string&gt; vec4;
         copy(istream_iterator&lt;string&gt;(cin), istream_iterator&lt;string&gt;(),     //copy source range
             back_inserter(vec4));                                           //copy dest, insert everything into vec4 from input stream
         copy(vec4.begin(),vec4.end(),ostream_iterator&lt;string&gt;(cout, " "));  //dump vec4 to cout with " " as delimiter       
         //merge the 2 copy operation above into one:
         copy(istream_iterator&lt;string&gt;(cin),istream_iterator&lt;string&gt;(),
              ostream_iterator&lt;string&gt;(cout," "));  
            
      3. Reverse iterator: travese container in reversed order
         vector&lt;int&gt; vec = {4,5,6,7};
         reversee_iterator&lt;vector&lt;int&gt;::iterator&gt; ritr;
         for(ritr = vec.rbegin(); ritr!=vec.rend();ritr++)
             cout &lt;&lt; *ritr &lt;&lt; endl;     //prints: 7,6,5,4

      4. Move iterator (c++11): ??

  </Answer>
</QA>

<QA ID="22" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      Why is pre increment (++i) faster than post increment (i++) ?
  </Question>
  <Answer>
      pre increment is faster because post-increment i++ needs to keep old value before increasing its own value,
      so it needs to create a temporary variable to hold the old value.
  </Answer>
</QA>

<QA ID="23" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Please give some examples of algorithms function usage
  </Question>
  <Answer>
      functions:
      1: min_element(range)
      2: sort(range)
      3: reverse(range)
      4: copy(range, (iterator adapter))
      5: find_if(range, Boolfunction)
      //algorithms - mostly loops

      vector&lt;int&gt; vec = {4,2,5,1,3,9};
      vector&lt;int&gt;::iterator itr = min_element(vec.begin(),vec.end()); //itr =&gt;1

      //Note 1: Algorithm always process range in a half-open way: [begin,end)
      sort(vec.begin(),itr);   //vec:{2,4,5,1,3,9}
      reverse(itr,vec.end());  //vec: {2,4,5,9,3,1}    //itr=&gt;9

      // Note 2: vec2 needs to have at least space for 3 elements:
      vector&lt;int&gt; vec2(3);
      copy(itr,vec.end(),       //Source
            vec2.begin());      //Destination

      //Note 3:  (back_inserter is inserting at the end of a container, I guess)
      vector&lt;int&gt; vec3;
      copy(itr,vec.end(),back_inserter(vec3));  //insert, not overwrite
                   //back_insert_iterator is not efficient, slow, insert 1 at a time
      vec3.insert(vec3.end(),itr,vec.end());    //efficient, fast, insert all at a time

      //Note 4: algorithms with functions
      bool isOdd(int i){
           return i%2;
      }

      int main() {
         vector&lt;int&gt; vec ={2,4,5,9,2}
         vector&lt;int&gt;::iterator itr = find_if(vec.begin(),vec.end(),isOdd);  //itr =&gt;5
      }

      //Note 5: Algorithm with native c++ array
      int arr[4] = {6,3,7,4};
      sort(arr,arr+4);

  </Answer>
</QA>

<QA ID="24" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What are all the 5 implicit member functions of a class? 
     Or what are all 5 the functions which compiler implements for us if we don't define one?
  </Question>
  <Answer>
      1. default ctor
      2. copy ctor
      3. assignment operator
      4. default destructor
      5. address operator
  </Answer>
</QA>

<QA ID="25" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      what is the difference between new and malloc() in terms of memory allocation ?
  </Question>
  <Answer>
      In C++, if the runtime system cannot allocate sizeof(Fred) bytes of memory during p= new Fred(), 
      a std::bad_alloc exception will be thrown. 

      With malloc(), it will return NULL if allocation fails
  </Answer>
</QA>

<QA ID="26" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      Do I need to check for NULL before delete p?
  </Question>
  <Answer>
      No !
  </Answer>
</QA>


<QA ID="27" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      Name 6 operators that cannot be overloaded ?
  </Question>
  <Answer>
      (1) sizeof 
      (2) dot : .  
      (3) star: * 
      (4) arrow: -> 
      (5) Scope resolution operator: :: 
      (6) ?:
  </Answer>
</QA>

<QA ID="28" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      How many ways are there to initialize an int with a constant?
  </Question>
  <Answer>
      (1) int foo = 123;  
      (2) int bar(123);
  </Answer>
</QA>

<QA ID="29" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What are the debugging methods or steps you use ?
  </Question>
  <Answer>
      1. GDB, DBG, Forte, Visual Studio.     (Forte for java ?)
      2. Analyzing the Core dump.
      3. Using tusc to trace the last system call before crash. (HP ?)
      4. Putting Debug statements in the program source code.
  </Answer>
</QA>

<QA ID="30" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
    Why do C++ compilers need name mangling?
  </Question>
  <Answer>
        Name mangling is the rule according to which C++ compiler changes function's name
    into function signature before passing that function to a linker. This is how a linker 
    differentiates between different functions with the same name.
  </Answer>
</QA>

<QA ID="31" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What are C++ storage classes?
  </Question>
  <Answer>
      There are 4 storage classes: 
                       Lifetime:
        1. auto        Function Block       
        2. register    Function Block       
        3. static      Whole Program
        3. extern      Whole Program

         auto: the default. Variables are automatically created and initialized when they 
               are defined and are destroyed at the end of the block containing their 
               definition. They are not visible outside that block.
         (another auto for data type / class) auto i = 1; //i is auto declared as integer, c++11 ?)
         register: a type of auto variable. a suggestion to the compiler to use a 
               CPU register for performance.
         static: a variable that is known only in the function that contains its 
               definition but is never destroyed and retains its value between calls 
               to that function. It exists from the time the program begins execution.
         extern: a static variable whose definition and placement is not determined until
               all object and library modules are combined (linked) to form the executable 
               code file. It can be visible outside the file where it is defined.

  </Answer>
</QA>

<QA ID="32" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is an Iterator class?
  </Question>
  <Answer>
      A class that is used to traverse through the objects maintained by a container class.
  </Answer>
</QA>
<QA ID="33" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      How can I open a stream in binary mode?
  </Question>
  <Answer>
      Use std::ios::binary.
  </Answer>
</QA>
<QA ID="34" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What constant defined in &lt;climits&gt; header returns the number of bits in a char?

      a) CHAR_SIZE    
      b) SIZE_CHAR    
      c) BIT_CHAR   
      d) CHAR_BIT
  </Question>
  <Answer>
      d, CHAR_BIT
  </Answer>
</QA>
<QA ID="35" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      The size_t integer type in C++ is?
  </Question>
  <Answer>
      Unsigned integer of at least 16 bits.

          The size_t type is used to represent the size of an object. 
      Hence, it&#39;s always unsigned. According to the language specification, 
      it is at least 16 bits.
  </Answer>
</QA>
<QA ID="36" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What are 3 float types? if extended precision is required, which one shoule be used ?
  </Question>
  <Answer>
      3 types are: float, double and long double. 
      Should use long double for extended precision.
  </Answer>
</QA>
<QA ID="37" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      If a decimal precision setting is required, what function to use and what header to include?
  </Question>
  <Answer>
      Use setprecision(int p) function and include header &lt;iomanip&gt; for input/output manipulation
  </Answer>
</QA>
<QA ID="38" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      In which type are the enumerators stored by the compiler?

      a) string
      b) integer
      c) float
      d) none of the mentioned

  </Question>
  <Answer>
      b
  </Answer>
</QA>
<QA ID="39" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is the default calling convention for a compiler in c++?

      a) __cdecl
      b) __stdcall
      c) __pascal
      d) __fastcall	
  </Question>
  <Answer>
      a
  </Answer>
</QA>
<QA ID="40" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      Function pointer example
  </Question>
  <Answer>
      #include &lt;iostream&gt;
      using namespace std;

      int add(int first, int second){
         return first + second + 15;
      }

      int operation(int first, int second, int(*functocall)(int, int)){
         return (*functocall)(first, second);
      }

      int main(){
        int  a;
        int(*plus)(int, int) = add;
        a = operation(15, 10, plus);
        cout &lt;&lt; a;
        return 0;
      }
  </Answer>
</QA>

<QA ID="41" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is keyword volatile and how to use it ?
  </Question>
  <Answer>
        C's volatile keyword is a qualifier that is applied to a variable when it is declared. 
      It tells the compiler that the value of the variable may change at any time--without 
      any action being taken by the code the compiler finds nearby. 

      volatile is used to prevent changes from compiler optimization; 

      2 ways to declare it:

      volatile uint16_t x; 
      uint16_t volatile y;

      if you really must have a volatile pointer to a volatile variable, you'd write:

      uint16_t volatile * volatile p_y;

      It is used for things like memory-mapped I/O registers

      Proper Use of C's volatile Keyword:

        A variable should be declared volatile whenever its value could change unexpectedly. 
      In practice, only three types of variables could change:

      1. Memory-mapped peripheral registers
      2. Global variables modified by an interrupt service routine
      3. Global variables accessed by multiple tasks within a multi-threaded application

          Embedded systems contain real hardware, usually with sophisticated peripherals. 
      These peripherals contain registers whose values may change asynchronously to the 
      program flow. As a very simple example, consider an 8-bit status register that is 
      memory mapped at address 0x1234. It is required that you poll the status register 
      until it becomes non-zero. The naive and incorrect implementation is as follows:

      uint8_t * p_reg = (uint8_t *) 0x1234;

      // Wait for register to read non-zero 
      do { ... } while (0 == *p_reg)

      This code will almost certainly fail as soon as you turn compiler optimization on.
  </Answer>
</QA>

<QA ID="42" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      By default members of a structure are: 
       A - private
       B - protected
       C - public
       D - Access specifiers not applicable for structures
  </Question>
  <Answer>
      C.  default members of a class is private, structure is public 
  </Answer>
</QA>

<QA ID="43" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      Can a constructor be virtual
  </Question>
  <Answer>
      No! (but why ? explain!)
  </Answer>
</QA>

<QA ID="44" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is the output of the following program ?
       
      #include &lt;iostream&gt;
      using namespace std;

      class Base{
      public:
          void f(){ cout &lt;&lt; "base\n"; }
      };

      class Derived:public Base {
      public:
         void f() { cout &lt;&lt; "Derived\n";}
      };

      main(){
         Derived obj;
         obj.Base::f();
      }
       
      A - Base
      B - Derived
      C - Compile error
      D - None of the above    
  </Question>
     
  <Answer>
      A
  </Answer>
</QA>

<QA ID="45" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     #include &lt;iostream&gt;

     using namespace std;
     class abc{
        void f();
        void g();
        int x;
     };

     main(){
        cout &lt;&lt; sizeof(abc)&lt;&lt;endl;
     }

     A: 12
     B: 4
     C: 8
     D: Compile error
  </Question>
  <Answer>
      B.  it is the size of all variables, function declaration does not take any space
  </Answer>
</QA>

<QA ID="46" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     In the following program, is f() overloaded ?
 
     void f(int x){}
     void f(signed x){}
     main() {}

  </Question>
  <Answer>
      No. Because Plain int is the same as signed, and is the same as signed int too.
  </Answer>
</QA>
<QA ID="47" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      Choose the respective delete operator usage for the expression: ptr=new int[100];
 
      A: delete ptr;
      B: delete ptr[];
      C: delete [] ptr;
      D: []delete ptr;
  </Question>
  <Answer>
      C
  </Answer>
</QA>
<QA ID="48" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      An exception is 
    
      A: Runtime error
      B: Compile time error
      C: Logical error
      D: None of the above

  </Question>
  <Answer>
      D. Exception is not an error. 
         Difference between Exception and Error is: 
         Exceptions are those which can be handled at the run time whereas errors cannot be handled.
  </Answer>
</QA>
<QA ID="49" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      Pick up the valid declaration for overloading ++ in postfix form where T is the class name:
     
      A: T operator++();
      B: T operator++(int);
      C: T &#38; operator++();
      D: T &#38; operator++(int);
  </Question>
  <Answer>
      B. (but why ? look it up !)
  </Answer>
</QA>
<QA ID="50" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      HAS-A relationship between the classes is shown through:

      A: Inheritance
      B: Container classes
      C: Polymorphism
      D: None of the above
  </Question>
  <Answer>
      B. Not A, It is B ! For example: A car is-a vehicle but A car has-a steering wheel
  </Answer>
</QA>
<QA ID="51" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is the output of the following program ?
 
     #include &lt;iostream&gt;

     using namespace std;
     void main(){
         char *s = "Fine";
         *s = 'N';
         cout &lt;&lt; s &lt;&lt; endl;
     }

     A: Fine
     B: Nine
     C: Compile error
     D: Runtime error

  </Question>
  <Answer>
      D. Not B: Runtime error: Exception thrown: write access violation

      if it was the line: char s[]="Fine"; 
      the answer would be B:

      This is because char * s="asdf"; is equivlant of const char *s ="asdf";

      A literal string in a C program is considered to be read-only and the 
      compiler/linker/loader may arrange for the memory of that string to be in 
      memory that is protected against writing.

  </Answer>
</QA>
<QA ID="52" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is the output of the following program ?
 
     #include &lt;iostream&gt;

     using namespace std;
     void main(){
         class student{
            int rno=10;
         } v;
         cout &lt;&lt; v.rno &lt;&lt; endl;
     }

     A: 10
     B: Garbage
     C: Compile error
     D: Runtime error

  </Question>
  <Answer>
      C. Not A, But C: Compile error. Because it is trying to access private member rno!
      class member is default to private. The test is testing for that knowledge !
  </Answer>
</QA>
<QA ID="53" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is the output of the following program ?

     #include &lt;iostream&gt;

     using namespace std;
     void main(){
         short unsigned int i=0;
         cout &lt;&lt; i-- ;
     }

     A: 0
     B: Compile error
     C: 65535
     D: 32767
  </Question>
  <Answer>
      A. Not C, it is A ! Because i-- is post increment, it will return 0 before 
      decreases and becomes 65535 (All bit set, since it is unsigned, it is 65535)
  </Answer>
</QA>

<QA ID="54" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Which operator is required to be overloaded as member function only ?

     A: _
     B: __
     C: ++ (postfix version)
     D: =
  </Question>
  <Answer>
      D. The "=" can not be overloaded as an independent function, like other operators do.
  </Answer>
</QA>

<QA ID="55" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is the output of the following program ?

     #include &lt;iostream&gt;

     using namespace std;
     class abc {
     public:
        int i;
        abc(int i) {
           i=i;
        }
     };
     void main(){
        abc m(5);
        cout &lt;&lt; m.i;
     }

     A: 5
     B: Garbage
     C: Error at the statement i=i;
     D: Compile error: i declared twice.

  </Question>
  <Answer>
      B. Not A, it is B ! Because i in constructor is defined in constructor as int, which
      hides the class variable i, so the 2 i's in the constructor are all i as the argument
      and the class variable i never get a change to be initialized and left with garbage!
  </Answer>
</QA>
<QA ID="56" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is the output of the following program ?

     #include &lt;iostream&gt;

     void main(){
        int r, x=2;
        float y=5;
        r=y%x;
        cout &lt;&lt; r;
     }

     A: 1
     B: 0
     C: 2
     D: Compile error

  </Question>
  <Answer>
      D. Not A, it is D ! Because y can't be float, it must be an integer to be meaningful.
  </Answer>
</QA>

<QA ID="57" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is a generic class ?

     A: Function template
     B: Class template
     C: inherited class
     D: None of the above
  </Question>
  <Answer>
     D. or the answer should be template class, not class template!
     Templates are the foundation of generic programming, which involves writing code in a way 
     that is independent of any particular type. A template is a blueprint or formula for 
     creating a generic class or a function.    
  </Answer>
</QA>

<QA ID="58" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Identify the c++ compiler of Linux:

     A: cpp
     B: g++
     C: Borland
     D: vc++

  </Question>
  <Answer>
     B, not A !
  </Answer>
</QA>

<QA ID="59" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is the output of the following program ?

     #include &lt;iostream&gt;

     void main(){
        float t=2;
        switch(t){
        case 2: cout &lt;&lt "Hi";
        default:cout &lt;&lt; "Hello";
        }
     }

     A: Hi
     B: HiHello
     C: Hello
     D: Error
  </Question>
  <Answer>
     D.  Because the switch only takes integer !
  </Answer>
</QA>
<QA ID="60" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Which is the storage specifier used to modify the member variable even though
     the class object is a constant object ?

     A: auto
     B: register
     C: static
     D: mutable
  </Question>
  <Answer>
     D. Example Snippet: 
     class Foo {
     private:
        mutable bool done;
     public:
        void doSomething() const{    //&lt;==notice the keyword const
            done=true;               //&lt;==but can still modify mutable vars
        }
     };
  </Answer>
</QA>
<QA ID="61" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     That is the full form of RTTI ?

     A: Runtime type identification
     B: Runtime template identification
     C: Robust Template Type Inheritance
     D: None of the above

  </Question>
  <Answer>
     A
  </Answer>
</QA>

<QA ID="62" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is the output of the following program ?

     #include &lt;iostream&gt;
      
     using namespace std; 
     void main(){
        char s[]="C++";
        cout &lt;&lt; s &lt;&lt;" ";
        s++;
        cout &lt;&lt; s &lt;&lt;" ";
     }

     A: C++ C++
     B: C++ ++
     C: ++ ++
     D: Compile error
  </Question>
  <Answer>
     D, Not B: although in char * s and char s[], s can be both used as an pointer, 
     but s[] can not be used to do pointer math operations like post increment calculations!
  </Answer>
</QA>
<QA ID="63" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     With respective to streams, operator &gt;&gt; is called as

     A: Insertion operator
     B: Extraction operator
     C: Right shift operator
     D: Left shift operator
  </Question>
  <Answer>
     B. &gt;&gt; is extraction operator and &lt;&lt; is insertion operator!
  </Answer>
</QA>
<QA ID="64" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Which feature of the OOP gives the concept of reusability ?

     A: Abstraction
     B: Encapsulation
     C: Inheritance
     D: None of the above
  </Question>
  <Answer>
     C
  </Answer>
</QA>

<QA ID="65" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is the output of the following program ?

     #include &lt;iostream&gt;
      
     using namespace std; 
     void main(){
        int *p= new int;
        delete p;
        delete p;
        cout &lt;&lt; "Done";
     }

     A: Done
     B: Compile error
     C: Runtime error
     D: None of the above
  </Question>
  <Answer>
     C !, but why ? do some research on this when you have time !!!
  </Answer>
</QA>

<QA ID="66" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      what is the difference between stack and heap ?
  </Question>
  <Answer>
     Stack is used for static memory allocation and Heap for dynamic memory allocation.  
       
     Use stack if you know the size before compile time.
     Use heap if you do not know the size until runtime.

     In a multi-threaded situation each thread will have its own completely independent 
     stack but they will share the heap. Stack is thread specific and Heap is application 
     specific. The stack is important to consider in exception handling and thread executions.

  </Answer>
</QA>

<QA ID="67" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     A trigraph character begins with:

     A: #
     B: ##
     C: ?
     D: ??

  </Question>
  <Answer>
     D.  In computer programming, digraphs and trigraphs are sequences of 
     two and three characters, respectively, that appear in source code and, 
     according to a programming language's specification, should be treated 
     as if they were single characters.

     According to C++'03 Standard 2.3/1:

     Before any other processing takes place, each occurrence of one of the 
     following sequences of three characters (trigraph sequences) is replaced 
     by the single character indicated in following Table:

    ----------------------------------------------------------------------------
    | trigraph | replacement | trigraph | replacement | trigraph | replacement |
    ----------------------------------------------------------------------------
    | ??=      | #           | ??(      | [           | ??&lt;     | {            |
    | ??/      | \           | ??)      | ]           | ??&gt;     | }            |
    | ??&#39;      | ^           | ??!      | |           | ??-     | &apos;            |
    ----------------------------------------------------------------------------
  </Answer>
</QA>
<QA ID="68" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     "cin" is an __

     A: Class
     B: Object
     C: Package
     D: Namespace
  </Question>
  <Answer>
     B, an object !
  </Answer>
</QA>
<QA ID="69" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What are the 4 operators that have to be overloaded as members ?
  </Question>
  <Answer>
     1: The assignment operator=()
     2: The function call operator()()
     3: The subscript operator[]()
     4: The class member access operator->()
  </Answer>
</QA>
<QA ID="70" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Choose the option not applicable for the constructor:
     
     A: Cannot be called explicitly
     B: Cannot be overloaded
     C: Cannot be overridden
     D: None of the above
  </Question>
  <Answer>
     C, Cannot be overidden.
  </Answer>
</QA>
<QA ID="71" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     From the below class choose the proper definition of the member function f().

     A: template&lt;class T&gt;
        void abc&lt;T&gt;::f(){}

     B: template&lt;class T&gt;
        void abc::f(){}

     C: template&lt;T&gt;
        void abc&lt;class T&gt;::f(){}

     D: template&lt;T&gt;
        void abc&lt;T&gt;::f(){}
  </Question>
  <Answer>
     A
  </Answer>
</QA>
<QA ID="72" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is the size of "int" ?
     
     A: 2
     B: 4
     C: 8
     D: Compiler dependent
  </Question>
  <Answer>
     D
  </Answer>
</QA>

<QA ID="73" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     i) Exceptions can be traced and controlled using conditional statements
     ii) For critical exceptions compiler provides the handler

     A: Only (i) is true
     B: Only (ii) is true
     C: Both (i) and (ii) are true
     D: Both (i) and (ii) are false
  </Question>
  <Answer>
     B
  </Answer>
</QA>
<QA ID="74" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     How do I initialize a pointer to a function ?
  </Question>
  <Answer>
     void fun(int a){}
     void main(){
        void (*fp)(int);    //declare a pointer fp to a function
        fp=fun;             //initialize the pointer
        fp(1);              //call the function
     }
  </Answer>
</QA>
<QA ID="75" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What does extern mean in a function declaration ?
  </Question>
  <Answer>
     Extern indicates that the function&apos;s definition is in another source file. 
     But there is no formal difference between extern int a (); and int a (); 
  </Answer>
</QA>
<QA ID="76" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is a pointer ?
  </Question>
  <Answer>
     A pointer is a variable which contains the address in memory of another variable.
  </Answer>
</QA>
<QA ID="77" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is a NULL pointer ?
  </Question>
  <Answer>
     A NULL pointer is a pointer that does not point to any object or function
  </Answer>
</QA>
<QA ID="78" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     There are three major features in object-oriented programming, what are they ?
  </Question>
  <Answer>
     1: Encapsulation
     2: Inheritance
     3: Polymorphism
  </Answer>
</QA>
<QA ID="79" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What are 3 kinds of polymorphism that C++ supports ?
  </Question>
  <Answer>
     1: ad-hoc polymorphism (through function overloading, and implicit conversions), 
     2: parametric polymorphism (through template specializations and tag dispatching), 
     3: subtype polymorphism (through the virtual function call mechanism).

     The first two (or sometimes just the template-based one) are also referred to as 
     static polymorphism, compared to the dynamic polymorphism of virtual calls.
  </Answer>
</QA>
<QA ID="80" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is function overloading ?
  </Question>
  <Answer>
     Function overloading is a programming concept that allows programmers to define 
     two or more functions with the same name and in the same scope. Each function has 
     a unique signature, which is derived from:

      1: function name
      2: number of arguments
      3: arguments' type
      4: arguments' order

      return type is not included in making function signature
  </Answer>
</QA>
<QA ID="81" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What are the 2 major cause of stack overflow ?
  </Question>
  <Answer>
     1: Infinite or very deep recursive call
     2: Assign a very large size variable on stack
  </Answer>
</QA>

<QA ID="82" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is cout and what is cin in STL ?
  </Question>
  <Answer>
     std::cout and std::cin are global objects of classes std::ostream and std::istream 
     respectively, of which they've overloaded operator &lt;&lt; and &gt;&gt; 
  </Answer>
</QA>

<QA ID="83" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     how can we pass an object into a thread by reference so that we can get the return value from it?
  </Question>
  <Answer>
     by using std::ref(obj);
 
     Snippet:
     class Fnctor{
     public:
        void operator()(string &amp; msg){
           cout &lt;&lt; "t1 says: "&lt;&lt; msg &lt;&lt; endl;
           msg="Trues is the mother of deceit";        //pass back a diff msg to show it is by ref
        }
     };
     void main(){
       string s="main org msg";     //notice how to pass a param to thread the line below, use 2nd parm to thread
       std::thread t1((fnctor())), std:ref(s));  //extra pair of () is needed here to make t1 not a def of fn
       t1.join();                   //if not use ref() here, it will auto use pass by value even though callee is &#38;msg 
       cout &lt;&lt; "From main: " &lt;&lt; s &lt;&lt; endl;
     }

     However, this could cause the 2 threads (parent and child) both have access to the same object, 
     so, access to it needs to be synchronized between the 2 threads.
     If this situation is required, we recommend using std::async() instead of spawn a thread!

     * To pass an object to thread by value is costly, by reference is not safe. 
      using move is both safe and efficient:
      std::thread t1((Fnctor()),std::move(s));

      * thead can not be copied, only be moved:
      std::thread t2 = std::move(t1);
      t2.join();

      * to get thread ID using:
       std::thread_thread::get_id()
       or
       t2.get_id();
  </Answer>
</QA>

<QA ID="84" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Through what do threads communicate with each other ?
     Through what do processes communicate ?
  </Question>
  <Answer>
     Threads communicate through shared memory
     Processes communicate through IPC, interprocess communication like files, pipes, message queues etc.
     Shared memory is faster than IPC.
     Threads can not be run on different computers.
     Processes can be run on a distributed system
  </Answer>
</QA>

<QA ID="85" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     How to use std::thread to spawn a thread ?
  </Question>
  <Answer>
     Snippet:

     void function_1(){}
     void main(){
        std::thread t1(function_1);  //t1 starts running
        t1.join() // main thread waits for t1 to finish here               
     }

     After a thread is spawn, it can join in or detach from 
     main thread once.
     
     To tell if a thread is joinable, do test first:

     if(t1.joinable())
        ti.join();

     //if not joinable, it will crash if you call join()
     //the thread can also detach from main thread:

      t1.detach(); //t1 will run freely, a daemon process, 
     // c++ runtime library will reclaim the resources when t1 finishes

     //if t1 is finished before it is detached or joined the main thread
     //the process will end!, so it has to be joined or detached before it finishes!

  </Answer>
</QA>

<QA ID="86" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is daemon ?
  </Question>
  <Answer>
     A daemon is a long-running background process that answers requests for services. 
     The term originated with Unix, but most operating systems use daemons in some 
     form or another. In Unix, the names of daemons conventionally end in "d". Some 
     examples include inetd , httpd , nfsd , sshd , named , and lpd 
  </Answer>
</QA>

<QA ID="87" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is lpd process doing ?
  </Question>
  <Answer>
     The lpd daemon places files specified in print requests in the directory 
     /var/spool/lpd. The print request is then managed by the qdaemon and the 
     appropriate backend (usually piobe) on the remote server. The /etc/locks/lpd file 
     contains the process ID of the currently running instance of the lpd daemon.

     Key words: /var/spool/lpd       //print request queue
                /etc/locks/lpd       //process ID
  </Answer>
</QA>

<QA ID="88" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is Spurious wakeup ?
  </Question>
  <Answer>
     Spurious wakeup describes a complication in the use of condition variables as provided 
     by certain multithreading APIs such as POSIX Threads and the Windows API.
     It is a wait-signal setup for multi-thread synchronizing machinism: 

     /* In any waiting thread: */
     while(!buf->full)
        wait(&#38;buf->cond, &#38;buf->lock);

     /* In any other thread: */
     if(buf->n >= buf->size){
	buf->full = 1;
	signal(&#38;buf->cond);
     }
     
  </Answer>
</QA>
<QA ID="89" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What does POSIX stand for ?
  </Question>
  <Answer>
     It stands for Portable Operating System Interface (POSIX). It is a family of standards 
     specified by the IEEE Computer Society for maintaining compatibility between operating 
     systems. POSIX defines the application programming interface (API), along with command
     line shells and utility interfaces, for software compatibility with variants of Unix 
     and other operating systems.

     It standarize the following area: 
       1. API
       2. command line shells
       3. Utility interfaces
  </Answer>
</QA>
<QA ID="90" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is called preemptive multitasking ?
  </Question>
  <Answer>
     Preemptive multitasking is a task in which a computer operating system uses some criteria 
     to decide how much time to allocate to any one task before giving another task a turn to use 
     the operating system. 
     The act of taking control of the operating system from one task and giving it to another 
     task is called preempting.
  </Answer>
</QA>
<QA ID="91" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is SaaS ?
  </Question>
  <Answer>
     Software as a service (SaaS) is a software licensing and delivery model in which 
     software is licensed on a subscription basis and is centrally hosted. SaaS is typically 
     accessed by users using a thin client via a web browser. SaaS has become a common delivery 
     model for many business applications, including office software, messaging software etc.
  </Answer>
</QA>
<QA ID="92" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is RESTful ?
  </Question>
  <Answer>
     Representational State Transfer (REST) is an architectural style that defines a set of 
     constraints and properties based on HTTP. Web Services that conform to the REST architectural 
     style, or RESTful web services, provide interoperability between computer systems on the Internet. 
     REST-compliant web services allow the requesting systems to access and manipulate textual 
     representations of web resources by using a uniform and predefined set of stateless operations. 
     Other kinds of web services, such as SOAP web services, expose their own arbitrary sets of 
     operations.
  </Answer>
</QA>
<QA ID="93" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     How to determin how many threads to use for the best performance ?
  </Question>
  <Answer>
     use this API function call:
     std::thread::hardware_concurrency();
  </Answer>
</QA>
<QA ID="94" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     How to avoid deadlock ?
  </Question>
  <Answer>
     1: Avoid using more than one mutex at the same time
     2: Avoid calling user function while holding one or more mutex
     3: Use std::lock() to lock more than one mutex if more than one mutex are needed.
     4: Lock more than one mutexes in the same order

  </Answer>
</QA>
<QA ID="95" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is a race condition ?
  </Question>
  <Answer>
     Race condition is the behavior of software where the output is dependent on the sequence or timing 
     of the other threads in a multi-threaded application. 
  </Answer>
</QA>
<QA ID="96" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     How to use mutex in c++ ?
  </Question>
  <Answer>
     1. Declare an mutex object:               std::mutex mu;  //accessible by all theads like a global variable
     2. Lock it before access shared resource: mu.lock();
     3. unlock it after access:                mu.unlock();
  </Answer>
</QA>
<QA ID="97" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Why the direct use of mutex is not recommended ? 
     What is recommended for using mutex ?
  </Question>
  <Answer>
     When mutex is used directly, if an exceptions happens while a thread is accessing the protected 
     resources while mutex is locked, then there would be no way to unlock the mutex and all the other 
     threads will be blocked from accessing forever.

     std::lock_guard class template is recommended to use with mutex. so, just use following line
     std::lock_guard&lt;std::mutex&gt; guard(mu);
     in the place of mu.lock() and remove the mu.unlock().
     when exception happens, guard will be destroyed and its destructor will auto unlock the mutex (RAII)
  </Answer>
</QA>
<QA ID="98" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is data race, now to avoid it ?
  </Question>
  <Answer>
     A data race occurs when 2 instructions from different threads in a single process access the same memory 
     location concurrently, and at least one of these accesses is a write and there is no synchronization 
     that is mandating any particular order among these accesses.

     To avoid data race:
      1. Use mutex to synchronize the data access
      2. Never leak a handle of data to outside
      3. Design interface appropriately
  </Answer>
</QA>
<QA ID="99" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is baffling ?
  </Question>
  <Answer>
     Very Strange     
     usage example:it appears baffling
  </Answer>
</QA>
<QA ID="100" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Which of the following is a pointer pointing to function ?
     
     A: int *a()
     B: int a(*a)
     C: int a()*
     D: int (*a)
  </Question>
  <Answer>
     A, I think !
  </Answer>
</QA>
<QA ID="101" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What are the 9 unary operators in c ?
  </Question>
  <Answer>
     1: - minus
     2: + plus
     3: ! logical negation
     4: ++ prefix/postfix increment
     5: -- prefix/postfix decrement
     6: &amp;  Address operator
     7: *  indrection operator
     8: () cast operator
     9: sizeof() operator
  </Answer>
</QA>
<QA ID="102" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is the output of the following program ?
     ...
     void main(){
        char c[]={'a','b','c','d'};
        char d[]="abcd";
        printf("%d - %d",sizeof(c),sizeof(d));
     }

     A: 4 - 4
     B: 4 - 5
     C: 5 - 5 
     D: 1 - 1
  </Question>
  <Answer>
     B. Length of a string includes the ending 0, size of array has no ending 0
  </Answer>
</QA>
<QA ID="103" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     In C, which of the following options is not a predefined function in string ?

     A: strcpy()
     B: strlen()
     C: strnicmp()
     D: None of the given options
  </Question>
  <Answer>
     D. strnicmp() is a predefined function !!!
  </Answer>
</QA>
<QA ID="104" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     Which of the following UNX commands is used to resursive listing of files ?
     
     A: ls -r
     B: ls -R
     C: ls -a
     D: ls -F
  </Question>
  <Answer>
     B
  </Answer>
</QA>
<QA ID="105" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     The mv commaind in UNIX will change:
 
     A: The i-node number
     B: only the directory entry
     C: directory and the i-node
     D: None of the options above

  </Question>
  <Answer>
     B
  </Answer>
</QA>
<QA ID="106" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     When used without arguments, the cd command in UNIX will:

     A: change to next directory
     B: bring back to previous directory
     C: bring back to home directory
     D: display an error
  </Question>
  <Answer>
     C
  </Answer>
</QA>
<QA ID="107" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     What does the cat command in UNIX do  ?

     A: Create a file
     B: Displays the contents of file
     C: Concatenates two files
     D: All of the given options
  </Question>
  <Answer>
     D, not B!
     You can create a new file with the name file1.txt using the following cat command 
     and you can type the text you want to insert in the file. Make sure you type 
     &apos;Ctrl-d&apos; at the end to save the file.

     cat > file1.txt
  </Answer>
</QA>
<QA ID="108" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     Which of the following UNIX commands is not a filter ?
     
     A: sort
     B: grep
     C: cal
     D: cut
  </Question>
  <Answer>
     C
  </Answer>
</QA>
<QA ID="109" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Which of the following UNIX commands cannot be used for communication in UNIX ?
     
     A: wall
     B: write
     C: mail
     D: more     
  </Question>
  <Answer>
     D
  </Answer>
</QA>
<QA ID="110" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is Unix command wall for ?
  </Question>
  <Answer>
     wall (an abbreviation of write to all) is a Unix command-line utility that displays the contents of a file 
     or standard input to all logged-in users. It is typically used by root to send out shutting down message 
     to all users just before poweroff.
  </Answer>
</QA>
<QA ID="111" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is write command in UNIX ?
  </Question>
  <Answer>
     In Unix and Unix-like operating systems, write is a utility used to send messages to another user 
     by writing a message directly to another user's TTY
  </Answer>
</QA>
<QA ID="112" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Fill in the blank:
     Function sub() is part of ____.

     A: sed
     B: awk
     C: grep
     D: nawk
     E: ak
  </Question>
  <Answer>
     B, ?
  </Answer>
</QA>
<QA ID="113" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Which of the following commands will you use to find a character or a word inside a string ?
     A: search
     B: find
     C: get
     D: grep
     E: wc -c
  </Question>
  <Answer>
     D, not B!
  </Answer>
</QA>
<QA ID="114" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     While asking for input from user, how to get first name in fname variable and lastname in lname 
     variable. Which of the following commands will allow you to do so ?
    
     A: By default, input will go to fname. you need to separate them inside code
     B: By default, input will go to lanme, you need to separate them inside code
     C: get fname lname
     D: read fname lname
     E: getname fname lname

  </Question>
  <Answer>
     D
  </Answer>
</QA>
<QA ID="115" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What software tool have you used for managing projects, tracking bugs ?
  </Question>
  <Answer>
     I have used: Jira, Rally, Conflunce, Bugzilla (Lexes) ,MKS (Application lifecycle management, used in Airblue) 
  </Answer>
</QA>
<QA ID="116" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     what does the keyword explicit for ?
  </Question>
  <Answer>
     Prefixing the explicit keyword to the constructor prevents the compiler from using that constructor 
     for implicit conversions. You have to cast it to do the conversion

     The explicit keyword prevents an implicit conversion
  </Answer>
</QA>
<QA ID="117" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is the difference between pointer and reference ?
  </Question>
  <Answer>
     A difference between pointers and references is that a pointer is an indepedent variable and can be 
     assigned NEW address values; whereas a reference, once assigned, can never refer to any new object 
     until the variable goes out of scope.

     snippet example:

       string s1("Nancy");
       string s2("Clancy");

       string &amp;rs = s1;  // rs refers to s1
       string *ps = &amp;s1; // ps points to s1

       Note: this looks like you can change what a reference refers, it actuallly changes refered variable value:
       rs = s2;          // rs still refers to s1,   
                         // but s1's value is now "Clancy"

       ps = &amp;s2;         // ps now points to s2; s1 is unchanged

       =========================================================
       The example shows the difference:
 
       reference assignment:  rs=s1;   //changes the value of variable it referes
       pointer assignment:    ps=&amp;s1;  //changes the address value the ps holds, make it points to a new 
                                       //variable holding the assigned value

       So, we can say that a reference to a variable is just an alias for the variable!
  </Answer>
</QA>
<QA ID="118" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
    What are 4 C++ style casts ?
  </Question>
  <Answer>
    C++ introducing 4 new cast operators:
     
    1: static_cast: for c cast except casting away the const
    2: const_cast: cast away the const-ness
    3: dynamic_cast: safe cast down or across an inheritance hierarchy casting from base into derived class objects.
                       return null if failed. no cast away const-ness
    4: reinterpret_cast: perform type conversions whose result is always implementation-defined. Used for casting function pointer types

    Snippet example:

    double result=(double)A/B;
    should become:
    double result=static_cast&lt;double&gt;A/B;
  </Answer>
</QA>
<QA ID="119" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Why should we always provide default constructors when we design a class ?
  </Question>
  <Answer>
     Default constructor is a one without argument!
     If a class lacks a default constructor, its use may be problematic in three contexts:

     1: Creation of arrays: when creating an array of objects, default constructor is always called.

     2: They are ineligible for use with many template-based container classes. Classes without default constructors 
        will be incompatible with many templates.

     3: Virtual base classes lacking default constructors are a pain to work with. That's because the arguments for 
        virtual base class constructors must be provided by the most derived class of the object being constructed. 
        As a result, a virtual base class lacking a default constructor requires that all classes derived from that 
        class - no matter how far removed - must know about, understand the meaning of, and provide for the virtual 
        base class&apos;s constructors&apos; arguments. Authors of derived classes neither expect nor appreciate 
        this requirement.
  </Answer>
</QA>
<QA ID="120" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is std::auto_ptr pointer in C++ standard library ?
  </Question>
  <Answer>
     std::auto_ptr was a class template available in the C++ Standard Library 
     (declared in the &lt;memory&gt; header file) that provided some basic RAII features for 
     C++ raw pointers. It has been replaced by the unique_ptr class.
  </Answer>
</QA>
<QA ID="121" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is difference between a member function and non-member function ?
  </Question>
  <Answer>
     3 differences:

     1: A non-member function always appears outside of a class
     2: They are called differently. for member fuction calls you have to specify object
     3: Member functions can be virtual and non-member functions can't.
  </Answer>
</QA>
<QA ID="122" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What are the cases where you should make a function a member function ?
  </Question>
  <Answer>
     3 cases:
     
     1) operator &lt;&lt; and operator &gt;&gt;
     2) Only non-member functions get implicit type conversions on all arguments
         so, if that is a need, make it a non-member functions. 
     3) if it also need to access non-public members of a class, make it a friend of the class.
  </Answer>
</QA>
<QA ID="123" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Why cannot the operator &lt;&lt; and &gt;&gt; be overloaded as member functions ?
  </Question>
  <Answer>
     When overloaded as a member function, a &lt;&lt; b is interpreted as a.operator&lt;&lt;(b), so it only takes 
     one explicit parameter (with this as a hidden parameter).

     Since this requires that the overload be part of the class used as the left-hand operand a (in a &lt;&lt; b), 
     it's not useful with normal ostreams and such. It would require that your overload be part of the ostream 
     class, not part of your class. Since you're not allowed to modify ostream, you can't do that. That leaves 
     only the global overload as an alternative.

     if you try to make it as a member function, it (operator &lt;&lt;) can only take one argument, with second being 
     self *this.

  </Answer>
</QA>
<QA ID="124" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     why should we avoid data members in public interface ??
  </Question>
  <Answer>
     1: Private variables help prevent people from depending on certain parts of your code
        It is easier to provide a steady interface when your design of the class changes.
     2: Public variables can be accessed from anywhere, makeing troubleshooting harder
  </Answer>
</QA>
<QA ID="125" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is difference between private and public inheriance ?
  </Question>
  <Answer>
     With private inheritance, public and protected member of the base class become private 
     members of the derived class
  </Answer>
</QA>
<QA ID="126" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     How to minimize compilation dependencies between files ?
  </Question>
  <Answer>
     1. Avoid using objects when object references and pointers will do.
     2. Use class declarations instead of class definitions whenever you can
     3. Don't #include header files in your header files unless your headers won't compile without them
  </Answer>
</QA>
<QA ID="127" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     How to keep people from calling an compiler auto generated member function ?
  </Question>
  <Answer>
     By declaring the member function explicitly and make it private!
  </Answer>
</QA>
<QA ID="128" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     How to declare const pointer and const data ?
  </Question>
  <Answer>
     char *p         = "Hello";       // non-const pointer, non-const data
     const char *p   = "Hello";       // non-const pointer, const data
     char * const p  = "Hello";       // const pointer, non-const data
const char * const p = "Hello";       // const pointer, const data
  </Answer>
</QA>
<QA ID="129" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Pass by reference or by value ?
  </Question>
  <Answer>
     
	1: pass-by-value is expensive: copy constructor and destructor will be called
	2: pass-by-reference is efficient: no copy constructor and destructor will be called
	3: pass-by-reference can avoid slicing problem

           if you have a small object - an int, for example - it may actually be more efficient 
        to pass it by value than to pass it by reference

  </Answer>
</QA>
<QA ID="130" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Why should we avoid overloading a function on a pointer and a numerical type ?
  </Question>
  <Answer>
     Because a pointer is actually a number, it will be confusing!
  </Answer>
</QA>
<QA ID="131" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What data members of a class must be initialized with initialization list ?
  </Question>
  <Answer>
     const members and referece members. Because those members can only be initialized, 
     never assigned inside constructor
  </Answer>
</QA>
<QA ID="132" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     How to order the initialization list ?
  </Question>
  <Answer>
     List members in an initialization list in the order in which they are declared.
     base class data members are initialized before derived class data members
  </Answer>
</QA>
<QA ID="133" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Why should we always make the base class&apos;s destructor virtual ?
  </Question>
  <Answer>
     When you try to delete a derived class object through a base class pointer and the base class
     has a non virtual destructor, the results are undefined. What often happens at runtime is that 
     the derived class's destructor is never called.
  </Answer>
</QA>
<QA ID="134" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     When should we not make a class&apos;s destructor virtual ? why ?
  </Question>
  <Answer>
     When a class is not intended to be used as a base class, making the destructor virtual is usually 
     a bad idea, Because:
     1: won&apos;t fit a 32 bit registers. 
     2: its object size doubles. 
     3: It will create a virtual table for virtual function pointers
  </Answer>
</QA>
<QA ID="135" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Why do you still need definition block when you declare a pure virtual destructor ?
  </Question>
  <Answer>
     You need this definition, because the way virtual destructors work is that the most derived 
     class&apos;s destructor is called first, then the destructor of each base class is called. 
     That means that compilers will generate a call to base class destructor even though the class
     is abstract, so you have to be sure to provide a body for the function. If you don't, the 
     linker will complain about a missing symbol.
  </Answer>
</QA>
<QA ID="136" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Why should we always return a reference to *this in member function operator=  ?
  </Question>
  <Answer>
     Because if you return void, it will prevent chains of assignment like x1=x2=x3=0; prevent 
     implicit type conversions at call sites, or both.
  </Answer>
</QA>
<QA ID="137" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Which of the following C++ classes is used for opening agile as read-only?

     A: ofstream
     B: ifstream
     C: fstream
     D: iostream
  </Question>
  <Answer>
     B
  </Answer>
</QA>
<QA ID="138" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Which one of the following programs do you run on your computer in order to allow connections 
     to your server using a serial terminal connected to a serial port ?

	a: login
	b: getty
	c: sh
	d: kermit
	e: tcflow
  </Question>
  <Answer>
     b.  getty, short for get &quot;teletype&quot;, is a Unix program running on a host computer 
     that manages physical or virtual terminals (TTYs). When it detects a connection, it prompts 
     for a username and runs the &apos;login&apos; program to authenticate the user.
  </Answer>
</QA>
<QA ID="139" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     which one of the following signal commands do you use to determin which siganls have been 
     sent to a process but which have not yet been processed?

	A: sigprocmask
	B: sigwaiting
	C: sigsent
	D: sigpending
	E: signal
  </Question>
  <Answer>
      D
  </Answer>
</QA>
<QA ID="140" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Explain how 2 processes communicate using message queue in unix.
  </Question>
  <Answer>
     Two (or more) processes can exchange information via access to a common system message queue. 
     The sending process places a message onto a queue which can be read by another process. Each 
     message is given an identification or type so that processes can select the appropriate message. 
     Process must share a common key in order to gain access to the queue in the first place.

     IPC messaging lets processes send and receive messages, and queue messages for processing in 
     an arbitrary order. Each IPC message has an explicit length. Messages can be assigned a specific 
     type. Because of this, a server process can direct message traffic between clients on its queue
     by using the client process PID as the message type. For single-message transactions, multiple 
     server processes can work in parallel on transactions sent to a shared message queue.

     Before a process can send or receive a message, the queue must be initialized (through the msgget 
     function) Operations to send and receive messages are performed by the msgsnd() and msgrcv() 
     functions, respectively.
  </Answer>
</QA>
<QA ID="141" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     which functions do unix programming message queue provide ?
  </Question>
  <Answer>
     They allow two or more processes to exchange information
  </Answer>
</QA>
<QA ID="142" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Please give example of key word &quot;using&quot; in c++11
  </Question>
  <Answer>
     using for type alias:
       usage: using identifier attr(optional) = type-id 
       example:

		// type alias, identical to
		// typedef void (*func)(int, int);

		using func = void (*) (int, int);

		void example(int, int) {}
		func f = example;

  </Answer>
</QA>

<QA ID="143" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     What is inode ?
  </Question>
  <Answer>
     The inode is a data structure that describes a filesystem object 
     such as a file or a directory. Each inode stores the attributes 
     and disk block location(s) of the object's data. 
     A directory contains (in its inode table) an entry for itself, 
     its parent, and each of its children.
  </Answer>
</QA>


<QA ID="144" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     What is inode number ?
  </Question>
  <Answer>
     An inode is an entry in inode table, containing information ( the metadata ) 
     about a regular file and directory

     Inode number also called index number, it consists following attributes.

     1: File types ( executable, block special etc )
     2: Permissions ( read, write etc )
     3: UID ( Owner )
     4: GID ( Group )
     5: FileSize
     6: Time stamps, including last access, last modification and last inode number change.
     7: File deletion time
     8: Number of links ( soft/hard )
     9: Location of File on harddisk.
     10:Some other metadata about file.

     to check inode number of file, use following command. The first field is inode number:

     $ls -il readme.txt
      1150561 -rw-r--r-- 1 root root 0 Mar 10 01:06 tecadmin.txt

     you can search for a file by inode number using find:

     $find -inum 1150561 
     ./readme.txt

     move and rename does not change the inode number (within one file system),  they only change
     the time stamps in inode table (a table for a directory for all its files, subdirs,parent dirs)
  </Answer>
</QA>

<QA ID="145" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     what is hardlink ?
  </Question>
  <Answer>
     A hard link is just an additional name for an existing file 
     Hard links can also be created to other hard links. Any number 
     of hard links, and thus any number of names, can be created for 
     any file. Hard links can also be created to other hard links. 
     However, they cannot be created for directories, and they cannot 
     cross filesystem boundaries or span across partitions

     Perhaps the most useful application for hard links is to allow 
     files, programs and scripts to be easily accessed in a different 
     directory from the original file or executable file. Typing the 
     name of the hard link will cause the program or script to be 
     executed in the same way as using its original name.
   
     use the command ln to create a hard link:
     $ln file1 hlink1 

     Example:

     $ ln aaa opennote
     $ ls -l
                 number of hlinks
                    |
	total 48K   V
	-rwxr-xr-x  2 yali.zhu None  748 Jun 20 14:55 aaa*
	drwxr-xr-x+ 1 yali.zhu None    0 Jun 17 23:52 bin/
	drwxr-xr-x+ 1 yali.zhu None    0 Jun 22 11:51 boostNote/
	drwxr-xr-x+ 1 yali.zhu None    0 Jun 20 14:56 C++Review/
	-rw-r--r--  1 yali.zhu None  177 Jun 18 12:06 commandsUsed.txt
	-rwxr-xr-x  1 yali.zhu None 6.1K Jun 21 12:29 JobSearch2018.txt*
	-rwxr-xr-x  2 yali.zhu None  748 Jun 20 14:55 opennote*
	-rwxr-xr-x  1 yali.zhu None  143 May 23 16:40 processChanges*
	-rwxr-xr-x  1 yali.zhu None  142 Jun  4 13:30 processChanges2*
	-rwxr-xr-x  1 yali.zhu None  144 Jun  4 13:32 processChanges2.bash*
	drwxr-xr-x+ 1 yali.zhu None    0 Jun  1 00:26 projects/
	drwxr-xr-x+ 1 yali.zhu None    0 Jun 19 23:21 yalishare/
	drwxr-xr-x+ 1 yali.zhu None    0 Jun 21 13:25 YaliSources/

        $ ls -il aaa opennote
        56013520365968768 -rwxr-xr-x 2 yali.zhu None 748 Jun 20 14:55 aaa*
        56013520365968768 -rwxr-xr-x 2 yali.zhu None 748 Jun 20 14:55 opennote*   //inode number is the same as aaa above

        $ find -inum 56013520365968768
        ./aaa
        ./opennote


  </Answer>
</QA>

<QA ID="146" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     what is softlink ?
  </Question>
  <Answer>
     A symbolic link, also termed a soft link, is a special kind 
     of file that points to another file, much like a shortcut in 
     Windows or a Macintosh alias. Unlike a hard link, a symbolic 
     link does not contain the data in the target file. It simply 
     points to another file(entry) somewhere in the file system.
     And it can cross filesystem boundaries

     Soft links is a special kind of file that points to another 
     file, much like a shortcut. Unlike a hard link, a symbolic 
     link does not contain the data in the target file. It simply 
     points to another entry somewhere in the file system. 

     To create a soft link:
     ln -s file linkname
     
     example:

     $ ln -s aaa opennoteSoft
     $ ls -il aaa open*
                       l in this column shows it is a softlink
                        |                                   Arrow shows where the soft link point to
                        V                                                         |
      56013520365968768 -rwxr-xr-x 2 yali.zhu None 748 Jun 20 14:55 aaa*          | 
      56013520365968768 -rwxr-xr-x 2 yali.zhu None 748 Jun 20 14:55 opennote*     v
      60517119993349091 lrwxrwxrwx 1 yali.zhu None   3 Jun 22 15:58 opennoteSoft -> aaa*    

  </Answer>
</QA>

<QA ID="147" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is difference between hardlink and soft link ?
  </Question>
  <Answer>
     This difference gives symbolic links certain qualities that 
     hard links do not have, such as the ability to link to directories, 
     or to files on remote computers networked through NFS. Also, when 
     you delete a target file, symbolic links to that file become unusable, 
     whereas hard links preserve the contents of the file. 

	inode &lt;--------
	   ^          |
	   |          | 
	myHardLink  myfile.txt &lt;----------  mySoftLink
  </Answer>
</QA>

<QA ID="148" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is a file descriptor ?
  </Question>
  <Answer>
     File descriptor is an abstract indicator used to access a file or other IO resource, 
     such as a file or network socket. It forms a part of the POSIX API. 
     A file descriptor is a non-negative integer and in C language, it is an integer.
     POSIX has 3 standard file descriptors:
   
     stdio.h file stream    Integer Value
     ------------------------------------
     stdin                    0
     stdout                   1
     stderror                 2
     ------------------------------------
  </Answer>
</QA>

<QA ID="149" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What does aka mean as in aka Unix Platform ?
  </Question>
  <Answer>
     aka is a short form of Also Known As. So, you would know this:
     Linux, aka Unix Platform, ...
   
  </Answer>
</QA>

<QA ID="150" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     What is process control block in Linux ?
  </Question>
  <Answer>
     Process Control Block (PCB, also called Task Controlling Block, Entry of 
     the Process Table, Task Struct, or Switchframe) is a data structure in 
     the operating system kernel containing the information needed to manage 
     the scheduling of a particular process
  </Answer>
</QA>

<QA ID="151" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     What is process table in Linux ?
  </Question>
  <Answer>
     Process table is a data structure in Linux kernel, which store information 
     about all currently running process. The process table contains process ID's, 
     memory usage of the process, all the file descriptors used in the process, etc.
  </Answer>
</QA>

<QA ID="152" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     What command to use to change file access permission ?
  </Question>
  <Answer>
     chmod
  </Answer>
</QA>

<QA ID="153" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     Where is shell located on linux system ?
  </Question>
  <Answer>
     $ echo $SHELL
     /bin/csh

  </Answer>
</QA>

<QA ID="154" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     What is a shell ?
  </Question>
  <Answer>
     The shell is a program that takes commands from the keyboard and gives them 
     to the operating system to perform.
  </Answer>
</QA>

<QA ID="155" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     What are the a few most popular shells nowadays ?
  </Question>
  <Answer>
     1: bash - GNU Bourne A-gain SHell
     2: ksh  - Korn Shell
     3: Zsh
     4: Fish - friendly interactive shell
     5: Tcsh / Csh, enhanced C shell, C like syntax

  </Answer>
</QA>

<QA ID="156" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     What does the export command do ?
  </Question>
  <Answer>
     We need to export the variable for it to be inherited by another program 
     - including a shell script
  </Answer>
</QA>

<QA ID="157" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     What are frequent use shell variables ?
  </Question>
  <Answer>
     Shell variables are usually named in uppercase.Most frequeltly used are:
     1. SHELL
     2. HOSTNAME
     3. HISTFILE
     4. HOME
     5. LOGONSERVER
     6. NUMBER_OF_PROCESSORS
     7. OS
     8. PWD
     9. TERM
     10. USERNAME
     11. USERDOMAIN
  </Answer>
</QA>

<QA ID="158" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     What does the finger command do ?
  </Question>
  <Answer>
     Finger may be used to look up users on a remote machine.
     It displays information about a user on a specified system running the
     finger service.
  </Answer>
</QA>

<QA ID="159" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     What does the logname command do ?
  </Question>
  <Answer>
     logname (stands for Login Name) is a program in Unix and Unix-like 
     operating systems that prints the name of the user executing the command.
  </Answer>
</QA>

<QA ID="160" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is Camel case in naming convension?
  </Question>
  <Answer>
     Camel case is the practice of writing compound words or phrases such that 
     each word or abbreviation in the middle of the phrase begins with a 
     capital letter, with no intervening spaces or punctuation.

     Example:
        thisIsAmerica, getProperties etc

     But Pascal Case is similar, with first letter capitalized:
        ThisIsAmerica, GetProperties etc
  </Answer>
</QA>

<QA ID="161" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is CGI ?
  </Question>
  <Answer>
     Common Gateway Interface
  </Answer>
</QA>

<QA ID="162" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     In Perl, all variables start with what ?
  </Question>
  <Answer>
     with $, like $abc, is a variable
     All variables are marked with leading sigils in perl script
  </Answer>
</QA>
<QA ID="163" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     In what areas is Perl used for ?
  </Question>
  <Answer>
     In addition to CGI, Perl 5 is used for system administration, network 
     programming, finance, bioinformatics, and other applications, such as 
     for GUIs, because of its flexibility and power.

     GUIs may be developed using Perl. For example, Perl/Tk and wxPerl are 
     commonly used to enable user interaction with Perl scripts. Such 
     interaction may be synchronous or asynchronous, using callbacks to 
     update the GUI.

  </Answer>
</QA>

<QA ID="164" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     what will the following program print ?
     
        class A {
        public:
           A() {}
           ~A() {
		throw 42;
	   }
        };

        void main() {
	  try {
		A a;
		throw 32;
	  }
	  catch (int a) {
		cout &lt;&lt; a;
	  }
	}
  </Question>
  <Answer>
     It wont print anything. The program will crash and throw an exception!
     Because the destructor is throwing an exception 42 before the previous 
     exception 32 is handled.

     Yes, destructors are guaranteed to be called on stack unwinding, including 
     unwinding due to exception being thrown. ... Destructor of the class is 
     not called if exception is thrown in its constructor. Exception is 
     automatically re-thrown if caught in construction initialization list 
     catch block.

     Never throw exception from destructors !
  </Answer>
</QA>

<QA ID="165" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     What does top command do ?
  </Question>
  <Answer>
     top command displays processor activity of your Linux box and also 
     displays tasks managed by kernel in real-time. It'll show processor 
     and memory are being used and other information like running processes. 
     This may help you to take correct action. top command found in 
     UNIX-like operating systems.
  </Answer>
</QA>

<QA ID="166" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     which command
  </Question>
  <Answer>
     which is a Unix command used to identify the location of executables. 
     The command takes one or more arguments; for each of these arguments, 
     it prints the full path of the executable to stdout that would have 
     been executed if this argument had been entered into the shell
  </Answer>
</QA>

<QA ID="167" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     who command ?
  </Question>
  <Answer>
     The standard Unix command who displays a list of users who are 
     currently logged into the computer. The who command is related to 
     the command w , which provides the same information but also 
     displays additional data and statistics.
  </Answer>
</QA>

<QA ID="168" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     w command ?
  </Question>
  <Answer>
     The command w on many Unix-like operating systems provides a quick 
     summary of every user logged into a computer, what each user is 
     currently doing, and what load all the activity is imposing on the 
     computer itself. The command is a one-command combination of several 
     other Unix programs: who, uptime, and ps -a.

     example:

     $ w
        11:12am up 608 day(s), 19:56,  6 users,  load average: 0.36, 0.36, 0.37
     	User     tty       login@  idle  what
	smithj   pts/5      8:52am       w
	jonesm   pts/23    20Apr06    28 -bash
	harry    pts/18     9:01am     9 pine
	peterb   pts/19    21Apr06       emacs -nw html/index.html
	janetmcq pts/8     10:12am 3days -csh
	singh    pts/12    16Apr06  5:29 /usr/bin/perl -w perl/test/program.pl
  </Answer>
</QA>

<QA ID="169" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     source command  ?
  </Question>
  <Answer>
     The source command can be used to load any functions file into the 
     current shell script or a command prompt. It reads and executes commands 
     from given FILENAME and return.
    
     The source command can be abbreviated as just a dot (.) in Bash and 
     similar POSIX-ish shells. 
  </Answer>
</QA>

<QA ID="170" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     tar command ?
  </Question>
  <Answer>
     The Linux &quot;tar&quot; stands for tape archive, which is used by large number 
     of Linux/Unix system administrators to deal with tape drives backup. 
     The tar command used to rip a collection of files and directories into 
     highly compressed archive file commonly called tarball or tar, gzip 
     and bzip in Linux
  </Answer>
</QA>

<QA ID="171" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     ifconfig command ?
  </Question>
  <Answer>
     ifconfig is a system administration utility in Unix-like operating 
     systems for network interface configuration. The utility is a command 
     line interface tool and is also used in the system startup scripts of 
     many operating systems.
  </Answer>
</QA>

<QA ID="172" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     How to use boost library lexical cast ?
  </Question>
  <Answer>
     lexical cast makes type conversion so much easier.
   1: #include "boost/lexical_cast.hpp"
   2: using boost::lexical_cast;
   3: using boost::bad_lexical_cast;
   4: ready to use it: convert an integer to string:
       int s=123;
       string str0=lexical_cast&lt;string&gt;(s);
       string str1=lexical_cast&lt;string&gt;(2.3);
       string str2=lexical_cast&lt;string&gt;('A');
       array&lt;char,64&gt; msg=lexical_cast&lt;array&lt;char,64&gt;&gt;(23);   //array with specific size is a type

       try {
          s=lexical_cast&lt;int&gt;("56.78");
       }catch(bad_lexical_cast &e}{
          cout &lt;&lt; e.what() &lt;&lt; endl;
       }

       s=lexical_cast&lt;int&gt;("5678yu");    //bad_lexical_cast
       s=lexical_cast&lt;int&gt;("5678yu",4);  //good

  </Answer>
</QA>

<QA ID="173" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     How to use boost library variant ?
  </Question>
  <Answer>
     boost variant to solve the traditional problem:
         union{int i; float f;} u;   //good:
         union{int i; string f;} u;  //bad
     usage:
     1: #include "boot\variant.hpp"
     2: declaration: 
         boost::variant&lt;int,string&gt; u1,u1;    //boost's way of union
         u1=2;
         u2="hello";
         u1=boost::get&lt;int&gt;(u1)*2;      //has to use get to change u1 to a number ?
         string st=boost::get&lt;string&gt;(u1);     //bad get
                st=boost::get&lt;string&gt;(u2);     //good get

         boost::variant &lt;int,string&gt; u3; //u3 is 0 now until you assign a number or a string

        //then how to know v's type ?
        void Double(boost:variant&lt;int, string&gt; v);

        //solution: using boost visitor template boost::static_visitor&lt;&gt;

        class DoubleVisitor : public boost::static_visitor&lt;&gt;{
        public:
           void operator()(int &1) cont{
               i+=i;
           }
           void operator()(string & str){
               str+=str;
           }
        };

        u1=2;

        boost::apply_visitor(DoubleVisitor(),u1);   //like creating a thread, passing argument 
                                                    //in second position, result: u1 becomes 4
        u2="hello";

        boost::apply_visitor(DoubleVisitor(),u2);   // u2 becomes "HelloHello"

        //visitor is like polymorphism on variant

        std::vector&lt;boost::variant&lt;int,string&gt;&gt; vec;
        vec.push_back("good");
        vec.push_back(23);
        vec.push_back("bad");
        DoubleVisitor f;
        for(auto x: vec){
           boost::apply_visitor(f,x);
        }

        //Note variant can never be empty, but any can be empty
  </Answer>
</QA>

<QA ID="174" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     How to use boost any ?
  </Question>
  <Answer>
     #include "boost\any.hpp"

     void main(){
        boost::any x,y,z;
        x=string("hello");
        x=2.3;
        y='z';
        z=vector&lt;int&gt;();
        //all these uses heap, dynamic storage
        //variant use stack storage, so more efficient;
   
        //to print any:
        cout &lt;&lt; boost::any_cast&lt;char&gt;(y) &lt;&lt;endl;  //return a copy of y's data 'z'
        cout &lt;&lt; boost::any_cast&lt;double&gt;(x) &lt;&lt;endl;  //return a copy of y's data 'z'
        cout &lt;&lt; boost::any_cast&lt;int&gt;(x) &lt;&lt; endl;  //throws exception: bad_any_cast
        cout &lt;&lt; boost::any_cast&lt;float&gt;(x) &lt;&lt; endl;  //throws exception: bad_any_cast: 
                                                    //must match exact type !        
        boost::any_cast&lt;vector&lt;int&gt;&gt;(z).push_back(23);   //this actually returns a copy 
                                                   //of the vector stored in z. so, 
                                                   //this line doesn't do anything meaningful
        int i=boost::any_cast&lt;vector&lt;int&gt;&gt;(z).push_back();  //crash because z is still 
                                                            // holding an empty vector!
        //back() Returns a reference to the last element in the vector.
   
        //store pointers:
        int i=5;
        boost::any p=&amp;i;
        int * pInt=boost::any_cast&lt;int*&gt;(p);
   
        //as a class:
        vector&lt;boost:any&gt; m;
        m.push_back(2);
        m.push_back('a');
        m.push_back(p);
        m.push_back(boost::any());    //a place holder
   
        //for store property settings
        struct Property{
           string name;
           boost::any value;
        };
        vector&lt;Property&gt; properties;
   
        //any can be empty:
        if(x.empty())
           cout &lt;&lt; "x is empty " &lt;&lt; endl;
	
     	//type can be checked only at runtime:
	if(x.type() == typeid(char))
	   cout &lt;&lt; "x is a char" &lt;&lt; endl;
   
     }


Note: boost::any's datatype can only be checked at runtime
  </Answer>
</QA>

<QA ID="175" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Boost Library ?
  </Question>
  <Answer>
     Boost is a set of libraries for the C++ programming language that provide support for tasks 
and structures such as linear algebra, pseudorandom number generation, multithreading, image processing, 
regular expressions, and unit testing. It contains over eighty individual libraries.

Most of the Boost libraries are licensed under the Boost Software License, designed to allow Boost to 
be used with both free and proprietary software projects. Many of Boost's founders are on the C++ standards 
committee, and several Boost libraries have been accepted for incorporation into both the C++ Technical 
Report 1 and the C++11 standard.

The libraries are aimed at a wide range of C++ users and application domains. They range from general-purpose 
libraries like the smart pointer library, to operating system abstractions like Boost FileSystem, to libraries 
primarily aimed at other library developers and advanced C++ users, like the template metaprogramming (MPL) 
and domain-specific language (DSL) creation (Proto).

In order to ensure efficiency and flexibility, Boost makes extensive use of templates. Boost has been a source 
of extensive work and research into generic programming and metaprogramming in C++.

Most Boost libraries are header based, consisting of inline functions and templates, and as such do not need 
to be built in advance of their use. Some Boost libraries coexist as independent libraries.
  </Answer>
</QA>

<QA ID="176" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Boost smart pointer ?
  </Question>
  <Answer>
    Smart pointers
     1.Scoped pointer: scoped_ptr

	#include &lt;boost/scoped_ptr.hpp&gt;

        struct Object{
           int value;
        }
        void main(){
	   boost::scoped_ptr&lt;int&gt; int_ptr(new int);   //delete itself when go out scope
           int_ptr.reset(new int);                    //
	
           boost::scoped_ptr&lt;Object&gt; ptr;
	   if(ptr) {
	    //do something here. but ptr is null now, so it won't come in here
	   }
	
	   ptr.reset(new Object);
	   if(ptr){
	     Object object=*ptr;
		ptr-&gt;value=5;
	   }
        }      
        //scope pointers 
        1)cannot copy
        2)cannot use STL containers 
        3)can swap with another scoped_ptr
        4)can reset

   2. shared pointer:

        #include &lt;boost/shared_ptr.hpp&gt;
        void main(){
           boost::shared_ptr&lt;int&gt; int_ptr(new int);
           Owner a(int_ptr);
           Owner b(int_ptr);
           Owner c(int_ptr);
           //no need to delete here anymore
           //you can copy it, can use with STL containers
        }
  </Answer>
</QA>

<QA ID="177" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     STL smart pointers
  </Question>
  <Answer>
     They are all class tempate:

	template&lt;class T&gt;
	std::shared_ptr&lt;T&gt;
	std::unique_ptr&lt;T&gt;
	std::weak_ptr&lt;T&gt;

	tempalte&lt;class T&gt;
	class weak_ptr;

	//less perfect way to create a shared pointer
	shared_ptr&lt;Dog&gt; p(new Dog("Gunner"));

	//prefered way to create a shared pointer:
	shared_ptr&lt;Dog&gt; p=make_shared&lt;Dog&gt;("Tank");

	shared poitner casting:
	//function tempalte for casting
	static_pointer_cast&lt;T&gt;
	dynamic_pointer_cast&lt;T&gt;
	const_poitner_cast&lt;T&gt;

	example:
	foo = std::dynamic_pointer_cast&lt;A&gt;(bar);

	//unique_ptr functions

	release()
	reset()
  </Answer>
</QA>

<QA ID="178" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Which one is the default c language pre-precessor on most standard Unix systems?

	a: gcc
	b: g77
	c: g++
	d: cpp
	e: php
  </Question>
  <Answer>
     Answer: D, the cpp, short for c pre-precessor
  </Answer>
</QA>

<QA ID="179" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     In the X window system, which of the following is true about the windows manager?

	A: It is a client application that maintains the "look and feel" 
           of other client application's windows
	B: It is the same as the X server
	C: It must run on the same machine as the X server.
  </Question>
  <Answer>
     Answer is A
  </Answer>
</QA>
<QA ID="180" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Why is fgets superior to gets?

	A: fgets uses I/O buffering for improved efficiency
	B: fgets takes a size parameter which is used to prevent buffer overflow
	C: fgets does type conversion
  </Question>
  <Answer>
     Answer is B
  </Answer>
</QA>
<QA ID="181" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What will happen when the following code is run ?
        int x;
	while (x &lt; 100) {
		cout &lt;&lt; x++;
	}

        A: The computer will output like 0123...99
        B: The computer will output 0123...100
        C: The output is undefined
        D: None of the above
  </Question>
  <Answer>
     when compile, got error C4700: uninitialized local variable 'x' used
     The error is compiler dependent. Correct answer should be undefined for 
     uninitialized local variable x

  </Answer>
</QA>
<QA ID="182" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     A relational operator is used to 
     A: combine values
     B: compare values
     C: distinguish different types of variables
     D: change variables to local values
  </Question>
  <Answer>
     B
  </Answer>
</QA>
<QA ID="183" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What does 7/9*9 equal to (in C and C++) ?
  </Question>
  <Answer>
     0
  </Answer>
</QA>
<QA ID="184" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Variables with names that describe the data stored at that particular memory location are called
     
     A: identifiers
     B: constant variables
     C: floating point variables
     D: mnemonic variables
  </Question>     
  <Answer>
     D
  </Answer>
</QA>
<QA ID="185" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     pushdown list means: 
     
     A: Stack
     B: Queue
     C: Linked List
     D: All of the ablove
  </Question>
  <Answer>
     A.  Push-down list - a list in which the next item to be removed is the item most recently stored (LIFO)
  </Answer>
</QA>
<QA ID="186" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     When must template functions have explicit template parameters ?

     A: always
     B: When the template types cannot be infered
     C: Never. The template types can always be inferred.
  </Question>
  <Answer>
     B
  </Answer>
</QA>
<QA ID="187" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     When are templates usually instantiated ?
     A: At runtime
     B: At compile time
     C: At link time
  </Question>
  <Answer>
     B
  </Answer>
</QA>
<QA ID="188" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Are templates conceptually related to polymorphism ?
     
     A: Nope
     B: Only when the template types are objects
     C: Yes, but compile-time polymorphism
  </Question>
  <Answer>
     C
  </Answer>
</QA>
<QA ID="189" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     In general, is it possible to completely hide the source code of a library written using templates ?

     A: Yes, but using export feature
     B: No, pretty much never
     C: Yes, all the time
  </Question>
  <Answer>
     B
  </Answer>
</QA>
<QA ID="190" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Which of the following describes a potentially surprising result of using templates ?

     A: Slower programs
     B: Poor variable naming in the debugger
     C: Increased executable size in comparison to the code base
  </Question>
  <Answer>
     C
  </Answer>
</QA>
<QA ID="191" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Following declarations are the same ?
       const char *s;
       char const *s;

  </Question>
  <Answer>
     True
  </Answer>
</QA>
<QA ID="192" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     When will this line fail to compile: new myObj[100]; ?
    
     A: Never
     B: when myObj is too large to fit into memory
     C: When myObj has no default constructor
  </Question>    
  <Answer>
     C

      When you have alternate constructor, the compiler will not generate a default constructor for you.
  </Answer>
</QA>
<QA ID="193" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is wrong with the following code ?

      int *x=(int*)malloc(100*sizeof(int));
      x=realloc(x,sizeof(int)*200);

      A: If realloc fails, then the original memory is lost
      B: Nothing, realloc is guaranteed to succeed (by returnning the original pointer)       
      C: Nothing, realloc frees the original memory passed to it

  </Question>
  <Answer>
      A
  </Answer>
</QA>
<QA ID="194" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is one possible symptom of having called free on the same block of memory twice ?

     A: Nothing, calling free twice on one block of memory always works fine
     B: Malloc might always return the same block of memory
     C: You cannot free any memory in the future
  </Question>
  <Answer>
     B.  
  </Answer>
</QA>
<QA ID="195" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Assuming this code were being compiled using a standards-conforming C++, what is wrong with it ?

     int *x = malloc(100*sizeof(int));
     x = realloc(x,sizeof(int));

     A: malloc is undefined in C++, you can only allocate memory using new
     B: Invalid cast from a void * to an int*
     C: Nothing is wrong with this code
  </Question>
  <Answer>
     B
  </Answer>
</QA>
<QA ID="196" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is a difficulty that arises with handling out of memory errors ?

     A: Many cleanup operations require extra memory
     B: Running out of memory rarely happens in systems that interact with users
     C: Once you have run out of memory, your program cannot continue
  </Question>
  <Answer>
     A
  </Answer>
</QA>
<QA ID="197" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is wrong with this line of code ?

     delete NULL;

     A: It causes a segmentation fault when delete trires to access NULL;
     B: Nothing
     C: It is undefined behavior
  </Question>
  <Answer>
     B
  </Answer>
</QA>
<QA ID="198" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Unions can contain most types in their member lists, except for 3 cases, which are what?
  </Question>
  <Answer>
     1. Class types that have constructors or destructors
     2. Class types that have user-defined assignment operators
     3. Static data members
  </Answer>
</QA>
<QA ID="199" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Can the anonymouse unions have function members ?
  </Question>
  <Answer>
     No
  </Answer>
</QA>
<QA ID="200" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Can you overload the constructor ?
  </Question>
  <Answer>
     Yes
  </Answer>
</QA>
<QA ID="201" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Throw an exception or return an error code ?
  </Question>
  <Answer>
     1. Exceptions leaves your code clean of all the checks necessary when testing 
        status returns on every call,
     2. Exceptions let you use the return value of functions for actual values,
     3. Exceptions can carry more information than a status return can,
     4. Exceptions can't be ignored through inaction, while status returns can.
  </Answer>
</QA>

<QA ID="202" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is C++ Singleton design pattern?
  </Question>
  <Answer>
     C++ Singleton class design pattern and methodology ensures that only one instance 
     of the C++ class is instantiated. 
     It usually implements a static method called instance() that returns a pointer to 
     its instance if already created or create a new one.

     2 advantages:
     1: Ensure a class has only one instance, and provide a global point of access to it.
     2: Encapsulated "just-in-time initialization" or "initialization on first use". 

     Snippet:
       Logger* Logger::Instance(){
          if (!m_pInstance)   // Only allow one instance of class to be generated.
             m_pInstance = new Logger;
 
          return m_pInstance;
       }

  </Answer>
</QA>
<QA ID="203" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     If we orverride a virtual method in derived class, do we have to prefix with &quot;virtual&quot; ?
  </Question>
  <Answer>
     No   
  </Answer>
</QA>



<QA ID="204" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is factory method design pattern ? what is the advantage of it ?
  </Question>
  <Answer>
      In Factory pattern, we create object without exposing the creation logic to client and 
      the client use the same common interface to create new type of object.

      Snippet example:

      class Stooge
      {
        public:
          // Factory Method
          static Stooge *make_stooge(int choice);
          virtual void slap_stick() = 0;
      };

      //hide how the object is created, just pick a choice:
      Stooge *Stooge::make_stooge(int choice)
      {
        if (choice == 1)
          return new Larry;
        else if (choice == 2)
          return new Moe;
        else
          return new Curly;
      }

      vector&lt;Stooge*&gt; roles;
      roles.push_back(Stooge::make_stooge(choice));
      
  </Answer>
</QA>
<QA ID="205" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is the 7 Layers of the OSI Model ?
  </Question>
  <Answer>
     The Open System Interconnection (OSI) model defines a networking framework to implement protocols 
     in seven layers. They are:

     Layer 7: Application Layer - supports application and end-user processes. Communication partners are identified.
     Layer 6: Presentation - This layer provides independence from differences in data representation by translating 
              from application to network format, and vice versa. 
     Layer 5: Session - This layer establishes, manages and terminates connections between applications
     Layer 4: Transport - provides transparent transfer of data between end systems, error recovery and flow control
     Layer 3: Network -provides switching and routing technologies, creating logical paths, known as virtual circuits
     Layer 2: Data Link - data packets are encoded and decoded into bits.
     Layer 1: Physical- conveys the bit stream - electrical impulse, light or radio signal  through 
              the network at the electrical and mechanical level
  </Answer>
</QA>
<QA ID="206" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is difference between VxWorks and Linux ?
  </Question>
  <Answer>
     vxWorks is Real time OS, Linux is a General Purpose Operating System (GPOS). GPOS's task scheduling is throughput based.
     RTOS is priority based. it uses pre-emptive task scheduling method and is light weight and small in size. The kernel 
     of an RTOS is preemptible where as a GPOS kernel is not preemptible.

     The primary features of the VxWorks OS include, but are not limited to, a multitasking kernel that includes pre-emptive 
     and round robin scheduling as well as fast interrupt response; memory protection, in order to isolate user applications 
     from the kernel; SMP support, an error handling framework; a file system; and local and distributed message queues.

  </Answer>
</QA>
<QA ID="207" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is SMP ?
  </Question>
  <Answer>
     Symmetric multiprocessing
  </Answer>
</QA>
<QA ID="208" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is Plmpl ?
  </Question>
  <Answer>
     It is the Pointer to implementation. It is a c++ programming technique that removes implementation details of a calss 
     from its object representation by placing them in a separate class, accessed through an opaque pointer (unique pointer)

     Users obtain a unique pointer to a lightweight or abstract base class, the implementation details are in the derived 
     class that overrides its virtual member functions.
  </Answer>
</QA>
<QA ID="209" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     how to prevent a class from being inherited  ?
  </Question>
  <Answer>
     Use the keyword "final" (c++11):
     class myClass final{};
  </Answer>
</QA>
<QA ID="210" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     how does Java achieve polymorphism ?
  </Question>
  <Answer>
     Static Polymorphism: It is achieved through function overloading and operator overloading.
     Dynamic Polymorphism : It is also called as run-time polymorphism. In this case java compiler does not know which 
     method is invoked at compilation time. Just JVM decides which method is invoked at the run-time. Method overriding 
     is example of run-time polymorphism. In this case overridden method is invoking through the super class reference 
     variable.
  
  </Answer>
</QA>
<QA ID="211" type="OneAnswer" category="GIT" countdown="0" resetto="0" >
  <Question>
     How to start tracking files in a directory using git ?
  </Question>
  <Answer>
     1. cd &lt;directory&gt;
     2. git init
     3. git add *.cpp *.h *.txt *.sln
     4. git commit -am "comment"
  </Answer>
</QA>
<QA ID="212" type="OneAnswer" category="GIT" countdown="0" resetto="0" >
  <Question>
     how to show difference between 2 commits ?
  </Question>
  <Answer>
     git diff [file]
     git diff &lt;hash1&gt; &lt;hash2&gt;
  </Answer>
</QA>
<QA ID="213" type="OneAnswer" category="GIT" countdown="0" resetto="0" >
  <Question>
     How to show which files are tracked in git ?
  </Question>
  <Answer>
     git ls-tree -r master --name-only
  </Answer>
</QA>
<QA ID="214" type="OneAnswer" category="GIT" countdown="0" resetto="0" >
  <Question>
     How to discard changes in git ?
  </Question>
  <Answer>
     git checkout -- filename       //discard chagnes in working directory
  </Answer>
</QA>
<QA ID="215" type="OneAnswer" category="GIT" countdown="0" resetto="0" >
  <Question>
     How to create a new branch from a history point in git ?
  </Question>
  <Answer>
     git branch &lt;new branch name&gt; &lt;hash of new branch root&gt;
  </Answer>
</QA>
<QA ID="216" type="OneAnswer" category="GIT" countdown="0" resetto="0" >
  <Question>
     How to make a branch and switch to the new branch ?
  </Question>
  <Answer>
     git checkout -b &lt;new branch name&gt;
  </Answer>
</QA>
<QA ID="217" type="OneAnswer" category="GIT" countdown="0" resetto="0" >
  <Question>
     How to merge 2 branches in git ?
  </Question>
  <Answer>
     1. swith to branch to be merged, like: git checkout branch1Name
     2. git merge branche2Name
  </Answer>
</QA>
<QA ID="218" type="OneAnswer" category="GIT" countdown="0" resetto="0" >
  <Question>
     How to cancel the merge ?
  </Question>
  <Answer>
     git merge --abort        //Cancel themerge just did with conflict
  </Answer>
</QA>
<QA ID="219" type="OneAnswer" category="GIT" countdown="0" resetto="0" >
  <Question>
     What is my github.com account ?
  </Question>
  <Answer>
     username: zhuyali2018
     pwd: jmjm?2?
     email:yali900@gmail.com
  </Answer>
</QA>
<QA ID="220" type="OneAnswer" category="GIT" countdown="0" resetto="0" >
  <Question>
     How to push to github ?
  </Question>
  <Answer>
     To push to github:
        1. get github URL, for example: https://github.com/zhuyali2018/Test.git
        2. add URL using command: git remote add origin &lt;URL&gt;
           example: git remote add origin https://github.com/zhuyali2018/Test.git
        3. verify the new remoet URL setting: git remote -v
        4. push using command: git push origin &lt;branch name&gt;
           example: git push origin master
                    git push origin new-branch-name
           Note, this last step needs to do in cmd.exe instread of cygwin: 
           NOTE: Actually just use git push, it defaults to current branch with origin
  </Answer>
</QA>
<QA ID="221" type="OneAnswer" category="GIT" countdown="0" resetto="0" >
  <Question>
     How to get from github repository first time ?
  </Question>
  <Answer>
     1. mkdir localdir
     2. cd localdir
     3. git init
     4. git remote add origin https://github.com/zhuyali2018/Test.git
     5. git remote -v   //verify origin set properly
        // for the first time, do fetch
     6. git fetch origin master
     7. git checkout master
 
     //if not the first time, just update:
     6. git pull origin master 
  </Answer>
</QA>
<QA ID="222" type="OneAnswer" category="GIT" countdown="0" resetto="0" >
  <Question>
     How to switch to a different branch in git ?
  </Question>
  <Answer>
     git checkout branchName
  </Answer>
</QA>
<QA ID="223" type="OneAnswer" category="GIT" countdown="0" resetto="0" >
  <Question>
     How to show commit history ?
  </Question>
  <Answer>
     git hist
  </Answer>
</QA>
<QA ID="224" type="OneAnswer" category="GIT" countdown="0" resetto="0" >
  <Question>
     How to remove files from git tracking ?
  </Question>
  <Answer>
     git rm --cached *.tlog
  </Answer>
</QA>
<QA ID="225" type="OneAnswer" category="GIT" countdown="0" resetto="0" >
  <Question>
     How to list branch names ?
  </Question>
  <Answer>
     git branch
  </Answer>
</QA>
<QA ID="226" type="OneAnswer" category="GIT" countdown="0" resetto="0" >
  <Question>
     How to set user name and email ?
  </Question>
  <Answer>
     git config --global user.name 'zhuyali2018'
     git config --global user.email 'yali900d@gmail.com'
     //used to track who did the commit
  </Answer>
</QA>
<QA ID="227" type="OneAnswer" category="GIT" countdown="0" resetto="0" >
  <Question>
     How to set popular git alias ?
  </Question>
  <Answer>
     //most popular configurations:
     git config --global alias.co checkout
     git config --global alias.ci commit
     git config --global alias.st status
     git config --global alias.br branch
     git config --global alias.hist "log --pretty=format:'%h %ad | %s%d [%an]' --graph --date=short"
     git config --global alias.type 'cat-file -t'
     git config --global alias.dump 'cat-file -p'
     git config --global alias.ls "ls-tree -r master --name-only"
     git config --global alias.tracked "ls-tree -r master --name-only"

     git config --global push.default simple
  </Answer>
</QA>
<QA ID="228" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     What should be at the first line of a shell script ?
  </Question>
  <Answer>
     #!/bin/bash
  </Answer>
</QA>
<QA ID="229" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     How to remove empty line ?
  </Question>
  <Answer>
     cat test.txt | sed '/^$/d'
  </Answer>
</QA>
<QA ID="230" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     How to add 5 spaces in front of each line ?
  </Question>
  <Answer>
     cat test.txt | sed -e 's/^/     /'
  </Answer>
</QA>
<QA ID="231" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     how to wrap to width of 90 ?
  </Question>
  <Answer>
     cat test.txt | fold -s -w90
  </Answer>
</QA>
<QA ID="232" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     How to get the phone number line containing a phone number in 999-999-9999 format ?
  </Question>
  <Answer>
     cat test.txt | egrep  "[[:digit:]]{3}-[[:digit:]]{3}-[[:digit:]]{4}"
  </Answer>
</QA>
<QA ID="233" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     how to get the substring following &quot;Email:&quot; ?
  </Question>
  <Answer>
     cat test.txt | awk -F'Email:' '{print $2}'
  </Answer>
</QA>
<QA ID="234" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     How to just print phone number from the line containing it ?
  </Question>
  <Answer>
     way 1:
       ttt="asdf asdf 813-528-6246 asdf lkjasdf"
       echo ${ttt//[!0-9-]/}
     Way 2:
       $ echo "asdf 234-123-4125 asdf" | grep -o -E '[0-9-]+'
       234-123-4125
     way 3:
       $ echo "asdf 234-123-4125 asdf" | sed 's/[^0-9-]*//g'
       234-123-4125
     Way 4:
       $ echo "asdf 234-123-4125 asdf" | tr -dc '0-9-'
       234-123-4125

       Note: -d: delete
             -c: complement: use the complement of SET1

  </Answer>
</QA>
<QA ID="235" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     How to kill 1000 processes in one line ?
  </Question>
  <Answer>
     for pid in $(ps -ef|grep yali|awk '{print $2}'); do kill -9 $pid; done
  </Answer>
</QA>
<QA ID="236" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     How to extract unique lines in shell scripting filter
  </Question>
  <Answer>
     sort file | uniq
     cat input1.txt | sort | uniq
  </Answer>
</QA>
<QA ID="237" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     How to filter for lines that just has 2 words ?
  </Question>
  <Answer>
     cat input1.txt | awk 'NF == 2'
  </Answer>
</QA>
<QA ID="238" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is key word override used for ?
  </Question>
  <Answer>
     Used in the derived class function declaration to explicitly mark the function as 
     override ones. Example:
     void f() override{}
  </Answer>
</QA>
<QA ID="239" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is difference between dynamic_pointer_cast and static_pointer_cast ?
  </Question>
  <Answer>
     static_pointer_cast to go up class hierarchy
     dynamic_pointer_cast to go down/across class hierarchy
  </Answer>
</QA>
<QA ID="240" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     About Anonymous Unions and Structures ?
  </Question>
  <Answer>
     Anonymous Unions and Structures are NOT part of C++ 11 standard, but most of the C++ 
     compilers support them. Since this is a C only feature, the C++ implementations don't 
     allow to anonymous struct/union to have private or protected members, static members, 
     and functions.

     Their definition looks like this:
        union 
        {
           char alpha;
           int num;
        };

        struct 
        {
           char alpha;
           int num;
        };

      They seem to have to be inside a named structure, like this:
      snippet:
      // C Program to demonstrate working of anonymous struct
      #include&lt;stdio.h&gt;
      struct Scope
      {
          // Anonymous structure
          struct
          {
              char alpha;
              int num;
          };
      };
 
      int main()
      {
          struct Scope x;
          x.num = 65;
          x.alpha = 'B';
 
          // Note that members of structure are accessed directly
          printf("x.alpha = %c, x.num = %d", x.alpha, x.num);
 
          return 0;
      }

  </Answer>
</QA>
<QA ID="241" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What are 4 types of members that an anonymous unions and structures cannot have ?
  </Question>
  <Answer>
     1. protected members
     2. private members
     3. static members
     4. member functions

     Note: In one word: Only public data members are allowed to have
  </Answer>
</QA>

<QA ID="242" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What tool do you use for static analysis of your code ?
  </Question>
  <Answer>
     I usually uses what comes with the IDE to do quick static analysis, 
     Such IDEs like Eclipse and Visual Studio that comes with Diagnostic Tools, 
     they all come with static analysis tool.
  </Answer>
</QA>

<QA ID="243" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     How to use Linux profiling Tool gprof ?
  </Question>
  <Answer>
     Using the gprof tool is not at all complex. You just need to do the following 
     on a high-level:

     1: Have profiling enabled while compiling the code (use "-pg" option: gcc -Wall -pg test.c -o test)
     2: Execute the program code to produce the profiling data (a new file "gmon.out" is generated)
     3: Run the gprof tool on the profiling data file (generated in the step above):
 
        gprof test gmon.out > analysis.txt

         The file is broadly divided into two parts :

         1. Flat profile
         2. Call graph

     The last step above produces an analysis file which is in human readable form. 
     This file contains a couple of tables (flat profile and call graph) in addition 
     to some other information. While flat profile gives an overview of the timing 
     information of the functions like time consumption for the execution of a 
     particular function, how many times it was called etc. On the other hand, 
     call graph focuses on each function like the functions through which a particular 
     function was called, what all functions were called from within this particular 
     function etc So this way one can get idea of the execution time spent in the 
     sub-routines too.

  </Answer>
</QA>

<QA ID="244" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     How to print just the match of regular expression ?
  </Question>
  <Answer>
     Use grep -oh &lt;regex&gt;:

     $ cat input1.txt | egrep -oh "[[:alpha:]]+[.][[:alpha:]]+[@][[:alpha:]]+.com"
     Rashmi.pal@idctechnologies.com
     rashmi.pal@idctechnologies.com
  </Answer>
</QA>

<QA ID="245" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What happens when an exeption is thrown ?
  </Question>
  <Answer>
     When an exception is thrown, the control passes from a try block to a handler, 
     the C++ run time calls destructors for all automatic objects constructed since 
     the beginning of the try block. This process is called stack unwinding. 
     The automatic objects are destroyed in reverse order of their construction.
  </Answer>
</QA>

<QA ID="246" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is wrong with following code ?

     struct aaa {
	int x;	
     };
     
     void main() {
	struct aaa * b;
	b = new aaa;
	memset(b, 0, sizeof(b));
     }
  </Question>
  <Answer>
     sizeof(b) is wrong. It is meant to reset memory block pointed by b
     for the size of the block and sizeof(b) does not mean the size of the block
     it returns size of the pointer, which is usually 4. Should use sizeof(aaa);
  </Answer>
</QA>

<QA ID="247" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     How to filter for the length of line in shell script ?
  </Question>
  <Answer>
     Using awk:
     cat input.txt | awk 'length($0) &lt; 40'    #$0 referes to current line
  </Answer>
</QA>

<QA ID="248" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     How to filter for the number of space delimited words in shell script ?
  </Question>
  <Answer>
     cat input.txt | awk 'NF &lt;= 4'         #awk default to space delimiter
  </Answer>
</QA>

<QA ID="249" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     How to just print the match of regular expression at line processing in shell script ?
  </Question>
  <Answer>
     use grep -oh regex
     it prints a line for each match in current line!
  </Answer>
</QA>

<QA ID="250" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     In line processing, how to print just the part from postion 5 to the end of line ?
  </Question>
  <Answer>
     use cut:
     cat input.txt | cut -b 5-
  </Answer>
</QA>

<QA ID="251" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     In line processing, how to remove leading spaces on each line ?
  </Question>
  <Answer>
      cat input.txt | sed 's/^[ ]*//'
  </Answer>
</QA>

<QA ID="252" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     In vi, how to search for a string case insensitive ?
  </Question>
  <Answer>
     /\cYourSearchString
  </Answer>
</QA>

<QA ID="253" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     How to display the first argument of last command in linux ?
  </Question>
  <Answer>
    echo $_

    Example:
    $ cat /etc/passwd
    $ echo $_
    /etc/passwd 
  </Answer>
</QA>

<QA ID="254" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     How to change command line console prompt ?
  </Question>
  <Answer>
     By assigning value to PS1. Example:

     PS1='($PWD)-> '      ==>     (/tms/pdswork/zhuyali/inf-us902/PDS)->
  </Answer>
</QA>

<QA ID="255" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     How to test for file existance in shell script ?
  </Question>
  <Answer>
   if [ -f /apps/cadapps/bin/promptstr ]; then
      PS1='$(/apps/cadapps/bin/promptstr -m -s -p) '
   else
      PS1='$(hostname):$PWD '
   fi

   # another way:
   if [ -e $1 ]; then
     echo "$1 exists"
   fi
  </Answer>
</QA>

<QA ID="256" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
    What do following environment variables mean ?

     1: HOME
     2: SHELL 
     3: PWD
     4: SECONDS
  </Question>
  <Answer>
     1: HOME - home directory, a default argument for CD command
     2: SHELL- path name of the shell: /bin/bash
     3: PWD  - current working directory
     4: SECONDS - Number of seconds since the shell was invoked
  </Answer>
</QA>

<QA ID="257" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     How to list directory names only under current directory ?
  </Question>
  <Answer>
     ls */ -ld
  </Answer>
</QA>

<QA ID="258" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     How to process command line arguments inside a shell script ?
  </Question>
  <Answer>
    while [ $# -ne 0 ]  # while (( $# != 0 ))
    do
       if [ $1 = "-long" ]; then
          FULLPATH="TRUE"
      else
          if [ "$FULLPATH" = "FALSE" ]; then
             echo "FULLPATH is false"
          else
             echo "FULLPATH" is true"
          fi
      fi
      shift 1
    done   
  </Answer>
</QA>

<QA ID="259" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     In line processing, how to grep lines start with fn or end with us ?
  </Question>
  <Answer>
     cat f.txt | grep ^fn
     cat f.txt | grep us$
  </Answer>
</QA>

<QA ID="260" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     How to define a function for shell script ?
  </Question>
  <Answer>
     function yalifun {
        echo "I am in function"
     }

     yalifun       #call a function
  </Answer>
</QA>

<QA ID="261" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is Metaprogramming ?
  </Question>
  <Answer>
     Metaprogramming is a programming technique in which computer programs 
     have the ability to treat programs as their data. It means that a 
     program can be designed to read, generate, analyse or transform other 
     programs, and even modify itself while running.
  </Answer>
</QA>

<QA ID="262" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Can inline function be recursive ?
  </Question>
  <Answer>
    The compiler creates a call graph; when a cycle is detected calling 
    itself, the function is no longer inlined after a certain depth 
    (n=1, 10, 100, whatever the compiler is tuned to). Some recursive 
    functions can be transformed into loops, which effectively 
    infinitely inlines them.
  </Answer>
</QA>
<QA ID="263" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is R programming language ?
  </Question>
  <Answer>
    R is a programming language and free software environment for statistical 
    computing and graphics that is supported by the R Foundation for Statistical 
    Computing.
  </Answer>
</QA>
<QA ID="264" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     how to use ssh ?
  </Question>
  <Answer>
    ssh user@server[:port]
    or ssh server  #if authrised with currently logged on user
  </Answer>
</QA>
<QA ID="265" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     how to check the last command status ?
  </Question>
  <Answer>
    echo $?        #0 means successful
  </Answer>
</QA>
<QA ID="266" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     How to check local disk space ?
  </Question>
  <Answer>
    dh -m       # -m means in megabyte -k means in kilobite
  </Answer>
</QA>
<QA ID="267" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     how to get the path without file name ?
  </Question>
  <Answer>
    $dirname /aaa/bbb/ccc
    /aaa/bbb
    $basename /aaa/bbb/ccc
    ccc
  </Answer>
</QA>
<QA ID="268" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     how to keep a process running after you have logged out?
  </Question>
  <Answer>
    nohup command-with-options &amp;

    When using the command shell, prefixing a command with nohup prevents 
    the command from being aborted automatically when you log out or exit 
    the shell.

    nohup mycommand

    Run the command mycommand. It will not receive input. All output, 
    including any error messages, will be written to the file nohup.out 
    in the working directory, or in your home directory. If mycommand is 
    running when you log out or close the terminal, mycommand will not 
    terminate.

    nohup mycommand &amp;

    Same as the previous command, but this form (when using the bash shell) 
    returns immediately to the shell prompt. The "&amp;" symbol at the end of 
    the command instructs bash to run nohup mycommand in the background. 
    It can be brought back to the foreground with the fg bash builtin command.

    When using &amp;, you'll see the bash job ID in brackets, and the process 
    ID (PID) listed after. For example:

    [1] 25132
 
    You can use the PID to terminate the process prematurely. For instance, 
    to send it the TERM (terminate) signal with the kill command:

    kill -9 25132
    
  </Answer>
</QA>
<QA ID="269" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     How to check folder spaces taken under current directory ?
  </Question>
  <Answer>
    du -sh *
   -s: summary, no recursive deep
   -h: human readable

   * this command can list all folders, including hidden ones recursively
  </Answer>
</QA>
<QA ID="270" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     How to check current shell pid ?
  </Question>
  <Answer>
    echo $$
  </Answer>
</QA>
<QA ID="271" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     how to look for a file from current directory ?
  </Question>
  <Answer>
    find -name filename
    find -name filename1 -o -name filename2   #-o means or; without -o means AND
    $ find -type d -name ou*      #look for folder, when using *, atleast 2 letters
    ./YaliSources/tinyxml2/resources/out
    ./YaliSources/xmltest/Project1/resources/out
    $ find -type f -name ou*      #look for file, when using *, atleast 2 letters
    ./work/output.txt
    ./work/output1.txt
    ./work/output2.txt

  </Answer>
</QA>
<QA ID="272" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What about find command other usages ?
  </Question>
  <Answer>
    1. Find hidden files
        find -type f -name ".*"
    2. find by permissions:
        find . -type f -perm 0777
        find . -type f ! -perm 0777
    3. Find readonly files
        find /etc -maxdepth 1 -perm /u=r
    4. Find executable files
        find /bin -maxdepth 2 -perm /a=x
        find -type f -perm /a=x
    5. Find files belonging to particular user
        find -user zhuyali
    6 Search files belonging to group
        find -group cad
    7 find files modified N days back:      find -mtime 50   (exactly 50 days ago)
    8 find files accessed N days back:      find -mtime 50    (if +50, means more than 50 days ago)
    9 find files changed in last N minutes: find -cmin -60    (within last 60 min)
   10 find files modified in last hour:     find -mmin -60
   11 Find Accessed Files in Last 1 Hour:   find -amin -60   
   12 To find all the files which are greater than 50MB and less than 100MB:
         find -size +50M -size -100M
   13 actions on files and folders found: 
          find ULOG.* -type f -exec rm -f {} \;
             using -exec &lt;cmd&gt; {} \;

  </Answer>
</QA>
<QA ID="273" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Script arguments manipulation list
  </Question>
  <Answer>
    If a script receives two arguments, $@ is equivalent to $1 $2
    wrappedProgram "$@"
    wrappedProgram "$*"
    wrappedProgram $*

    Example: Calling
    wrapper "1 2  3" 4 5 "6 7"

    will result in:
    "$@": wrappedProgram "1 2  3" 4 5 "6 7"
    "$*": wrappedProgram "1 2  3 4 5 6 7"
     $* : wrappedProgram 1 2 3 4 5 6 7

    $# : number of parameters passed in
    $! : pid of most recently executed
  </Answer>
</QA>
<QA ID="274" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is jobs command ?
  </Question>
  <Answer>
    "jobs" list background processes

    $ notepad input1.txt &
    [1] 30672
    $ jobs
    [1]+  Running                

  </Answer>
</QA>
<QA ID="275" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is tty, pty, pts respectively ?
  </Question>
  <Answer>
    A pty (pseudo terminal device) is a terminal device which is emulated by an 
          other program (example: xterm, screen, or ssh are such programs).
    A pts is the slave part of a pty
    
    A tty is a regular terminal device (the console on your server, for example).
    A pts is a psuedo terminal slave (an xterm or an ssh connection).
  </Answer>
</QA>
<QA ID="276" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is command pwd with command -L and -P mean ?
  </Question>
  <Answer>
    Print the name of the current working directory.
    Options:
      -L        print the value of $PWD if it names the current working
                directory
      -P        print the physical directory, without any symbolic links

    By default, `pwd' behaves as if `-L' were specified.

  </Answer>
</QA>
<QA ID="277" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     how to send error to a file or hide them from showing up at stdout ?
  </Question>
  <Answer>
    grep -r "asdf" * 2>/dev/null
    grep -r "asdf" * 2>~/tmp/errfile.out
  </Answer>
</QA>
<QA ID="278" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     how to dump a command output to vi for editing ?
  </Question>
  <Answer>
    command | vi -
  </Answer>
</QA>
<QA ID="279" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     In Wndows, how to list where I shared my folder ?
  </Question>
  <Answer>
    use command:
      net share
  </Answer>
</QA>
<QA ID="280" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     In Wndows, how to list mapped drive ?
  </Question>
  <Answer>
    use command: net use
  </Answer>
</QA>
<QA ID="281" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     For a function pointer n, which is the correct way to use it ?
     A: (*n)(2);
     B: n(2);
  </Question>
  <Answer>
    Both are good. See the following snippet:

     #include &lt;iostream&gt;
     using namespace std;
     void func(int x)
     {
        cout &lt;&lt; x;
     }
     void main()
     {
        void(*n)(int);
        n = &amp;func;              // n = func; works the same !
        (*n)(2);                //For function pointer n, both lines work the same
        n(2);                   //For function pointer n, both lines work the same
     }
  </Answer>
</QA>
<QA ID="282" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     How to use namespace ?
  </Question>
  <Answer>
     #include &lt;iostream&gt;

     using namespace std;
     namespace AAA
     {
       void doSomething() {
       cout &lt;&lt; "in name space AAA" &lt;&lt; endl;
     }

     void main() {
       using namespace AAA;
       doSomething();
     }

  </Answer>
</QA>
<QA ID="283" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     does conversion from int to float lose data ?
  </Question>
  <Answer>
    Yes, It does. Conversion from int to double is OK!
  </Answer>
</QA>
<QA ID="284" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Does following code lose data ?

     int a=45; 
     int b=10;
     double c=a/b;

     what is the value of c ?

     A: 4.5
     B: 4
     C: 5
  </Question>
  <Answer>
     B. value of c is 4!

     it should be:

     int a=45; 
     int b=10;

     double a2=a;
     double c=a2/b;

     then c is 4.5

     if b is conveted to double, it is also OK. 
     Note: a or b, at least one of them, has to be double to avoid lossing 
     data in a/b calculation
  </Answer>
</QA>
<QA ID="285" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     if $phones prints "813-528-6246 407-347-8404", how to assign them to 
     $cell and $home respectively in shell script?
  </Question>
  <Answer>
    phoneArray=($phones)
    cell=${phoneArray[0]}
    home=${phoneArray[1]}
  </Answer>
</QA>
<QA ID="286" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     How to do any-number-of-arguments function ?
  </Question>
  <Answer>
     Summery: 
     va_list N;
     va_start(N,C);
        va_arg(N,int)
     va_end(N);

     Snippet:
     #include &lt;iostream>
     #include &lt;stdarg.h>
     using namespace std;
     double avg(int Count, ...)
     {
        va_list Numbers;          //Type to hold information about variable arguments (type)
        va_start(Numbers, Count); //Initialize a variable argument list (macro)
        int Sum = 0;
        for (int i = 0; i &lt; Count; ++i){
           Sum += va_arg(Numbers, int);
        }
        va_end(Numbers);          //End using variable argument list (macro)
        double avge = (double)Sum / Count;
        return avge;
     }
     void main()
     {
        double Average = avg(10, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9);
        cout &lt;&lt; "Average of first 10 whole numbers : " &lt;&lt; Average;
     }
  </Answer>
</QA>
<QA ID="287" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     A lambda expression has the form:

     [capture](parameters)->return-type {body}

     The [] construct inside a function call's argument list indicates the beginning
     of a lambda expression. Please give a lambda example.

  </Question>
  <Answer>
     #include &lt;iostream>
     #include &lt;algorithm> 
     void main()
     {
        char s[]="Hello World!";
        int Uppercase = 0; //modified by the lambda
        for_each(s, s+sizeof(s), [&amp;Uppercase] (char c) {
           if (isupper(c))
           Uppercase++;
        });
        cout&lt;&lt; Uppercase&lt;&lt;" uppercase letters in: "&lt;&lt; s&lt;&lt;endl;
     }

     It's as if you defined a function whose body is placed inside another function call.
     The ampersand in [&amp;Uppercase] means that the lambda body gets a reference to
     Uppercase so it can modify it. Without the ampersand, Uppercase would be passed
     by value. C++11 lambdas include constructs for member functions as well.
  </Answer>
</QA>
<QA ID="288" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What should you do to fix the compiling problem:

     error C3861: 'for_each': identifier not found
  </Question>
  <Answer>
    add this line: #include &lt;algorithm>
  </Answer>
</QA>
<QA ID="289" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     C+11 has changed the keyword "auto" to a new meaning, what is the new meaning ?
  </Question>
  <Answer>
     The keyword auto isn't new; it actually dates back the pre-ANSI C era. However,
     C++11 has changed its meaning; auto no longer designates an object with automatic 
     storage type. Rather, it declares an object whose type is deducible from its 
     initializer. The old meaning of auto was removed from C++11 to avoid confusion.

     Automatic Type Deduction:
        auto c='a'; //char
  </Answer>
</QA>
<QA ID="290" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     I've come across this term POD-type a few times. What does it mean?
  </Question>
  <Answer>
     POD stands for Plain Old Data - A Plain Old Data Structure in C++ is an aggregate 
     class that contains only PODs as members, has no user-defined destructor, no 
     user-defined copy assignment operator, and no nonstatic members of pointer-to-member 
     type.
  </Answer>
</QA>
<QA ID="291" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is C++11's Deleted and Defaulted Functions ?
  </Question>
  <Answer>
     struct A
     {
        A()=default; //C++11
        virtual ~A()=default; //C++11

     };
     The =default; part instructs the compiler to generate the default implementation 
     for the function

     The opposite of a defaulted function is a deleted function:

     int func()=delete;
     Which tells the compiler not to generate default implemnetation for this function.

  </Answer>
</QA>
<QA ID="292" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     How does c++11's nullptr fixed the NULL problem ?
  </Question>
  <Answer>
     nullptr replaces the bug-prone NULL macro and the literal 0 that have been used
     as null pointer substitutes for many years. nullptr is strongly-typed:

     void f(int);     //#1
     void f(char *);  //#2

     //C++03

     f(0);           //which f is called?

     //C++11

     f(nullptr)      //unambiguous, calls #2

     nullptr is applicable to all pointer categories, including function pointers and
      pointers to members:

     const char *pc=str.c_str(); //data pointers
     if (pc!=nullptr)
       cout&lt;&lt;pc&lt;&lt;endl;

     int (A::*pmf)()=nullptr; //pointer to member function

     void (*pmf)()=nullptr; //pointer to function
  </Answer>
</QA>
<QA ID="293" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is c++11's Delegating Constructors
  </Question>
  <Answer>
     In C++11 a constructor may call another constructor of the same class:

     class M //C++11 delegating constructors
     {

        int x, y;
        char *p;

     public:

        M(int v) : x(v), y(0), p(new char [MAX]) {}            //#1 target
        M(): M(0) {                                            //#2 delegating constructor
          cout&lt;&lt;"delegating ctor"&lt;&lt;endl;
        }     

     };

     Constructor #2, the delegating constructor, invokes the target constructor #1.
  </Answer>
</QA>
<QA ID="294" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Move semantics in C++11 is implemented for all STL containters, which means what ?
  </Question>
  <Answer>
    It means it would be OK to do call by value and return by value, pass by value with
    those STL container classes.
  </Answer>
</QA>
<QA ID="295" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is lvalue and what is rvalue ?
  </Question>
  <Answer>
    lvalue: An object that occupies some identifiable location in memory (not something in register)
            for example: variable a: int a;
    rvalue: Any object that is not a lvalue. for example: 5, a+5, sume(a+b), etc

     int &amp; r= 5;       //compiler err
     const int &amp; r=5;   //OK

     int square(int &amp; x) { return x*x;}
     square(i);    //OK
     square(5);     //compiler error

     int square(const int &amp; i){return x*x;}
     square(5);    //ok

  </Answer>
</QA>
<QA ID="296" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is rvalue reference ?
  </Question>
  <Answer>
     rvalue reference is a reference to rvalue, syntax as &amp;&amp;:
     int a = 5;   //a is a lvalue
     int &amp; b = a; //b is a lvalue reference (formerlly called reference before c++11)

     int &amp;&amp; c;    //c is a rvalue reference

     in use:
     void printInt( int&amp; i );    //#1
     void printInt( int&amp;&amp; i );   //#2

     void main(){
        printInt(a);     //call #1
        printInt(6);     //call #2
     }
    
  </Answer>
</QA>
<QA ID="297" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What have been added to c++11 library ?
  </Question>
  <Answer>
    C++11 added:
     1. new container classes (unordered_set, unordered_map, unordered_multiset, and unordered_multimap)
     2. and several new libraries for:
        1) regular expressions, 
        2) tuples, 
        3) function object wrapper 
        4) and more. 
  </Answer>
</QA>
<QA ID="298" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is new in C++11 in terms of threading library ?
  </Question>
  <Answer>
    c++11 new functions in STL Threading library :
     1) thread class
     2) promises and futures
     3) async(), function template for launching concurrent tasks
     4) tread_local storage type for declaring thread-unique data.
  </Answer>
</QA>
<QA ID="299" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What's new in c++11 in terms of smart pointer ?
  </Question>
  <Answer>
         C++98 defined only one smart pointer class, auto_ptr, which is now deprecated. 
     C++11 includes new smart pointer classes: shared_ptr and the recently-added unique_ptr. 
     Both are compatible with other Standard Library components, so you can safely 
     store these smart pointers in standard containers and manipulate them with
     standard algorithms.
  </Answer>
</QA>
<QA ID="300" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What's 7 new features that c++11 supports?
  </Question>
  <Answer>
     c+11 now supports:
     1. lambda expressions
     2. automatic type deduction of objects
     3. uniform initialization syntax: (), a uniform brace notation,
        and {} for aggregate
     4. delegating constructors
     5. deleted and defaulted function declarations
     6. nullptr
     7. rvalue references
  </Answer>
</QA>
<QA ID="301" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     C++11 Standard Library was also revamped with what 8 new features?
  </Question>
  <Answer>
     1. new algorithms,
     2. new container classes,
     3. atomic operations,
     4. type traits,
     5. regular expressions,
     6. new smart pointers,
     7. async() facility, and of course
     8. a multithreading library.

   c++11 lacks a GC but it does include a state-ofthe-art threading library.
  </Answer>
</QA>
<QA ID="302" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Who is the creator of C++ ?
  </Question>
  <Answer>
    Bjarne Stroustrup
  </Answer>
</QA>
<QA ID="303" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     C++11 cleans up this mess with a uniform brace notation initialization, 
     what does its syntax look like?
  </Question>
  <Answer>
     C++11 supports in-class initialization of data members:
     class X{
        int a[4];
        int b=7; //C++11 only  in-class initialization of data members
     public:
        X():a{1,2,3,4},b(7)  //C++11, member array initializer, member initializer(b)
        {
           ...
        }
     };
  </Answer>
</QA>
<QA ID="304" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     With c++ move semantics, what member functions are introduced ?
  </Question>
  <Answer>
     Introduced:
     1. move contructor (Rvalue reference constructor ?)
     2. move assignment operator
  </Answer>
</QA>
<QA ID="305" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is the usage of rvalue reference ?
  </Question>
  <Answer>
    1. Move semantics
    2. Perfect forwarding (relay, universal reference thing)
  </Answer>
</QA>
<QA ID="306" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
    In order to make a function defined in a C++ file callable from C, you need to
     A. declare the function in an extern "C" block.
     B. ensure the function isn't overloaded.
     C. declare the function as static.
     D. Both A and B.

  </Question>
  <Answer>
     D
     The extern "C" line tells the compiler that the external information sent to the
      linker should use C calling conventions and name mangling (e.g., preceded by a
     single underscore). Since name overloading isn't supported by C, you can't make
     several overloaded functions simultaneously callable by a C program. 
  </Answer>
</QA>
<QA ID="307" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Python Sample code ?
  </Question>
  <Answer>
     #!/usr/bin/python3
     # Some calculations.  Note the lack of semicolons.  Statements end at the end
     # of the line.  Also, variables need not start with a special symbol as in
     # perl and some other Unix-bred languages.
     fred = 18
     barney = FRED = 44                     # Case sensistive.
     bill = (fred + barney * FRED - 10)
     alice = 10 + bill / 100                 # Regular division does not truncate.
     alice2 = 10 + bill // 100               # But the // operator provides int div.
     frank = 10 + float(bill) / 100
     print("fred =", fred)
     print("FRED =", FRED)
     print("bill =", bill)
     print("alice =", alice)
     print("alice2 =", alice2)
     print("frank =", frank )
     print()

     # Each variable on the left is assigned the corresponding value on the right.
     fred, alice, frank = 2*alice, fred - 1, bill + frank
     print("fred =", fred)
     print("alice =", alice)
     print("frank =", frank )
     print()

     # Exchange w/o a temp.
     fred, alice = alice, fred
     print("fred =", fred)
     print("alice =", alice)
     print()

     # Python allows lines to be continued by putting a backslash at the end of
     # the first part.
     fred = bill + alice + frank - \
            barney
     print("fred =", fred)
     print()

     # The compiler will also combine lines when the line break in contained
     # in a grouping pair, such as parens.
     joe = 3 * (fred +
             bill - alice)
     print ("joe =", fred)

  </Answer>
</QA>
<QA ID="308" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Where is Python Sample code on web ?
  </Question>
  <Answer>
    http://sandbox.mc.edu/~bennet/python/code/index.html
  </Answer>
</QA>
<QA ID="309" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Perl Sample code ?
  </Question>
  <Answer>
     # Various operations on scalar (string) variables.
     $fred = "Fred here";
     $barney = 56;
     $sum = 10 + $barney;
     print 'The variable $fred' . " contains $fred.\n";
     print "Sum is $sum.\n";


     more on: http://sandbox.mc.edu/~bennet/perl/leccode/index.html
  </Answer>
</QA>
<QA ID="310" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     SQL Statement samples ?
  </Question>
  <Answer>
     Update table:

     UPDATE Customers
     SET ContactName = 'Alfred Schmidt', City= 'Frankfurt'
     WHERE CustomerID = 1;

     INSERT INTO Customers (CustomerName, ContactName, Address, City, PostalCode, Cou
     ntry)
     VALUES ('Cardinal', 'Tom B. Erichsen', 'Skagen 21', 'Stavanger', '4006', 'Norway
     ');


     SELECT * FROM Customers ORDER BY Country DESC;
     SELECT MIN(Price) AS SmallestPrice FROM Products;
     SELECT MAX(Price) AS LargestPrice FROM Products;
     SELECT COUNT(ProductID) FROM Products;
     SELECT AVG(Price) FROM Products;
     SELECT SUM(Quantity) FROM OrderDetails;

     SELECT * FROM Customers WHERE CustomerName LIKE '%or%';


     SELECT Orders.OrderID, Customers.CustomerName, Orders.OrderDate
     FROM Orders
     INNER JOIN Customers ON Orders.CustomerID=Customers.CustomerID;

     SELECT Customers.CustomerName, Orders.OrderID
     FROM Customers
     LEFT JOIN Orders ON Customers.CustomerID = Orders.CustomerID
     ORDER BY Customers.CustomerName;

     SELECT Customers.CustomerName, Orders.OrderID
     FROM Customers
     LEFT JOIN Orders ON Customers.CustomerID = Orders.CustomerID
     ORDER BY Customers.CustomerName;

     https://www.w3schools.com/sql/sql_join_right.asp

     SELECT COUNT(CustomerID), Country
     FROM Customers
     GROUP BY Country
     ORDER BY COUNT(CustomerID) DESC;

     SELECT COUNT(CustomerID), Country
     FROM Customers
     GROUP BY Country
     HAVING COUNT(CustomerID) > 5;

     CREATE DATABASE testDB

     DROP DATABASE testDB;

     CREATE TABLE Persons (
         ID int NOT NULL,
         LastName varchar(255) NOT NULL,
         FirstName varchar(255),
         Age int,
         PRIMARY KEY (ID)
     );

     CREATE TABLE Orders (
         OrderID int NOT NULL,
         OrderNumber int NOT NULL,
         PersonID int,
         PRIMARY KEY (OrderID),
         FOREIGN KEY (PersonID) REFERENCES Persons(PersonID)
     );

     SELECT * FROM Orders WHERE OrderDate='2008-11-11'
  </Answer>
</QA>
<QA ID="311" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     What is dmesg ?
  </Question>
  <Answer>
     dmesg (Display message or driver message) is a command which will show 
     Kernel ring buffers. These messages contain valuable information about 
     device drivers loaded into the kernel at the time of booting as well as 
     when we connect a hardware to the system on the fly. In other words 
     dmesg will give us details about hardware drivers connected to, 
     disconnected from a machine and any errors when hardware driver is 
     loaded into the kernel. These messages are helpful in diagnosing or 
     debugging hardware and device driver issues. Already covered command 
     in the series is.
     Examples of dmesg usage:
     dmesg |less
     dmesg > boot_messages
     dmesg | grep -i usb
     dmesg | grep -i tty    //to show all serial ports
     dmesg | grep -i memory
     dmesg | grep -i dma    //to confirm that the HDD(s) is running in DMA 
                              (direct memory access) mode

     The output of dmesg is maintained in the log file /var/log/dmesg, and it 
     can thus also be easily viewed by reading that file with a text editor, 
     such as vi or gedit, or with a command such as cat, e.g.,

     cat /var/log/dmesg | less     
  </Answer>
</QA>
<QA ID="312" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is kernel ring buffer ?
  </Question>
  <Answer>
     The kernel ring buffer is a data structure that records messages related to the operation
     of the kernel. A ring buffer is a special kind of buffer that is always a constant size,
     removing the oldest messages when new messages come in.
  </Answer>
</QA>
<QA ID="313" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     What is /etc directory for ?
  </Question>
  <Answer>
         This is the nerve center of your system, it contains all system related configuration
     files in here or in its sub-directories. A "configuration file" is defined as a local
     file used to control the operation of a program; it must be static and cannot be an
     executable binary
  </Answer>
</QA>
<QA ID="314" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     What is /sys directory for ?
  </Question>
  <Answer>
         Modern Linux distributions include a /sys directory as a virtual filesystem (sysfs,
     comparable to /proc , which is a procfs), which stores and allows modification of the
     devices connected to the system, whereas many traditional UNIX and Unix-like operating
     systems use /sys as a symbolic link to the kernel source tree.
  </Answer>
</QA>
<QA ID="315" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is /bin for ?
  </Question>
  <Answer>
    /bin contains commands that may be used by both the system administrator and by users, 
    but which are required when no other filesystems are mounted (e.g. in single user mode). 
    It may also contain commands which are used indirectly by scripts

    There must be no subdirectories in /bin.
    The following commands, or symbolic links to commands, are required in /bin:

     Command    Description
     cat        Utility to concatenate files to standard output
     chgrp      Utility to change file group ownership
     chmod      Utility to change file access permissions
     chown      Utility to change file owner and group
     cp         Utility to copy files and directories
     date       Utility to print or set the system data and time
     dd         Utility to convert and copy a file
     df         Utility to report filesystem disk space usage
     dmesg      Utility to print or control the kernel message buffer
     echo       Utility to display a line of text
     false      Utility to do nothing, unsuccessfully
     hostname   Utility to show or set the system's host name
     kill       Utility to send signals to processes
     ln         Utility to make links between files
     login      Utility to begin a session on the system
     ls         Utility to list directory contents
     mkdir      Utility to make directories
     mknod      Utility to make block or character special files
     more       Utility to page through text
     mount      Utility to mount a filesystem
     mv         Utility to move/rename files
     ps         Utility to report process status
     pwd        Utility to print name of current working directory
     rm         Utility to remove files or directories
     rmdir      Utility to remove empty directories
     sed        The `sed' stream editor
     sh         POSIX compatible command shell
     stty       Utility to change and print terminal line settings
     su         Utility to change user ID
     sync       Utility to flush filesystem buffers
     true       Utility to do nothing, successfully
     umount     Utility to unmount file systems
     uname      Utility to print system information



  </Answer>
</QA>
<QA ID="316" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     What is /proc directory in linux ?
  </Question>
  <Answer>
     The proc filesystem (procfs) is a special filesystem in Unix-like operating systems that
     presents information about processes and other system information in a hierarchical
     file-like structure, providing a more convenient and standardized method for dynamically
     accessing process data held in the kernel than traditional tracing methods or direct
     access to kernel memory. Typically, it is mapped to a mount point named /proc at boot
     time. The proc file system acts as an interface to internal data structures in the
     kernel. It can be used to obtain information about the system and to change certain
     kernel parameters at runtime (sysctl).

     The Linux kernel extends it to non-process-related data.

     The proc filesystem provides a method of communication between kernel space and user
     space. For example, the GNU version of the process reporting utility ps uses the proc
     file system to obtain its data, without using any specialized system calls.

     Linux implementation includes a directory for each running process, including kernel
     processes, in directories named /proc/&lt;PID>, where PID is the process number. Each
     directory contains information about one process, including:

     /proc/&lt;PID>/cmdline, the command that originally started the process.
     /proc/&lt;PID>/cwd, a symlink to the current working directory of the process.
     ...
  </Answer>
</QA>
<QA ID="317" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     How do display 10 lines after the line that contains MARKER, but not the one containing MARKER ?
  </Question>
  <Answer>
    cat file.txt | grep -A10 MARKER | grep -v MARKER
  </Answer>
</QA>
<QA ID="318" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     What is strace ?
  </Question>
  <Answer>
    strace is a diagnostic, debugging and instructional userspace utility for Linux. 
    It is used to monitor and tamper with interactions between processes and the Linux 
    kernel, which include system calls, signal deliveries, and changes of process state. 
    The operation of strace is made possible by the kernel feature known as ptrace.

    Some Unix-like systems provide other diagnostic tools similar to strace, such as truss.

    Simple Example: Trace Linux Command (ls) System calls:

    $ strace ls
    execve("/bin/ls", ["ls"], [/* 19 vars */]) = 0
    brk(NULL)                               = 0x1f31000
    access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
    access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
    open("/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
    fstat(3, {st_mode=S_IFREG|0644, st_size=25337, ...}) = 0
    ...
    getdents(3, /* 10 entries */, 32768)    = 320
    getdents(3, /* 0 entries */, 32768)     = 0
    close(3)                                = 0
    close(1)                                = 0
    close(2)                                = 0
    exit_group(0)                           = ?
    +++ exited with 0 +++
    $

    from above, you can see various types of system calls made by ls command, for example:
    
    open("/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3

    Where:

       - open - is the type of system call
       - ("/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) - system call argument
       - 3 - system call return value
  </Answer>
</QA>
<QA ID="319" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     What is ptrace ?
  </Question>
  <Answer>
     ptrace is a system call found in Unix and several Unix-like operating systems. By using 
     ptrace (the name is an abbreviation of "process trace") one process can control another, 
     enabling the controller to inspect and manipulate the internal state of its target. 

     ptrace is used by debuggers and other code-analysis tools, mostly as aids to software 
     development.

     ptrace is used by debuggers (such as gdb and dbx), by tracing tools like strace and
     ltrace, and by code coverage tools. ptrace is also used by specialized programs to patch
     running programs, to avoid unfixed bugs or to overcome security features. It can further
     be used as a sandbox and as a run-time environment simulator (like emulating root
     access for non-root software).

     By attaching to another process using the ptrace call, a tool has extensive control over
     the operation of its target. This includes manipulation of its file descriptors, memory,
     and registers. It can single-step through the target's code, can observe and intercept
     system calls and their results, and can manipulate the target's signal handlers and both
     receive and send signals on its behalf. The ability to write into the target's memory
     allows not only its data store to be changed, but also the application's own code
     segment, allowing the controller to install breakpoints and patch the running code of the
     target.

     As the ability to inspect and alter another process is very powerful, ptrace can attach
     only to processes that the owner can send signals to (typically only their own
     processes); the superuser account can ptrace almost any process (except init on kernels
     before 2.6.26). In Linux systems that feature capabilities-based security, the ability to
     ptrace is further limited by the CAP_SYS_PTRACE capability[5] or by the YAMA Linux
     Security Module. In FreeBSD, it's limited by FreeBSD jails and Mandatory Access
     Control policies.
  </Answer>
</QA>
<QA ID="320" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     What is command id?
  </Question>
  <Answer>
    id command is command which can print real and effective User ID (UID) and Group ID (GID).
    An UID is a single identity for a user.

    Example:

    $ id -un
    yali.zhu
    $ id -gn
    yaligrp

  </Answer>
</QA>
<QA ID="321" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     if A and B are linux commands, what is difference between the following 2 ?
     A &amp; B
     A &amp;&amp; B
  </Question>
  <Answer>
    template
  </Answer>
</QA>
<QA ID="322" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     if A and B are linux commands, what is difference between the following 2 ?
     A | B
     A || B
  </Question>
  <Answer>
    A | B : pipe operation: A's output goes to B's input
    A || B : logic, if A failed, execute B

    Try this example:
    ls  || ls -l     # ls -l wont run
    lsa || ls -l     # lsa command does not exist and thus failed, ls -l got a chance to run
  </Answer>
</QA>
<QA ID="323" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is /dev/kmsg ?
  </Question>
  <Answer>
    template
  </Answer>
</QA>
<QA ID="324" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     How to perform a process trace using tusc ?
  </Question>
  <Answer>
    template
  </Answer>
</QA>
<QA ID="325" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     how to set cout to print fixed width ?
  </Question>
  <Answer>
    1. #include &lt;iomanip>
    2. cout &lt;&lt; right &lt;&lt; setw(18) &lt;&lt; name.substr(0,18) &lt;&lt; ...;
  </Answer>
</QA>
<QA ID="326" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     if I want to use std::find_if(), which header file should I include ?    
  </Question>
  <Answer>
    #include &lt;algorithm>    
  </Answer>
</QA>
<QA ID="327" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     how to test for empty string variable ?     
  </Question>
  <Answer>
    if [ -z $name2 ]; then
     echo "name2 is null"
    else
     echo "name2 is not null"
    fi
  </Answer>
</QA>
<QA ID="328" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     What is !$ in shell script?     
  </Question>
  <Answer>
    !$ just repeats the last word from previous command.
    Example:

	$ echo Unix and Linux
	Unix and Linux
	$ echo !$
	echo Linux      #repeating "Linux"
        Linux

        $ cat dir1
        cat: dir1: Is a directory
        $ cd !$
        cd dir1

        $ls
        ....
        $ !$      # execute the last command, which is "ls"
        ....
        $ls -l
        ....
        $ !$      # execute the last argument as a command, which is "-l"
        -l
        -bash: -l: command not found

    
    Note:
        !  Start a history substitution
        $  means the last word. This is usually the last argument.

  </Answer>
</QA>
<QA ID="329" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     what does the following line do in linux shell ?
     cmd1 ; cmd2
  </Question>
  <Answer>
    executing cmd1 first, then executing cmd2 without waiting.
  </Answer>
</QA>
<QA ID="330" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     what does the following line do in linux shell ?
     cmd1 &amp;&amp; cmd2    
  </Question>
  <Answer>
    it means:
    if(cmd1); then
        cmd2
    fi
  </Answer>
</QA>
<QA ID="331" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     what does the following line do in linux shell ?
     cmd1 || cmd2   
  </Question>
  <Answer>
    it means:
    if( ! cmd1 ); then
        cmd2
    fi
  </Answer>
</QA>
<QA ID="332" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     how to simplify the following expression ?     
     x || x &amp;&amp; y
  </Question>
  <Answer>
      x || x &amp;&amp; y
    = x &amp;&amp; (1 || y)
    = x &amp;&amp; 1
    = x
  </Answer>
</QA>
<QA ID="333" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is Microsoft Azure?     
  </Question>
  <Answer>
     Microsoft Azure is a cloud computing service created by Microsoft for building, 
     testing, deploying, and managing applications and services through a global 
     network of Microsoft-managed data centers.
  </Answer>
</QA>
<QA ID="334" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     how to find public ip of my linux machine ?     
  </Question>
  <Answer>
    use dig command:

    /home/zhuyali>dig +short myip.opendns.com @resolver1.opendns.com
    40.76.74.83
  </Answer>
</QA>
<QA ID="335" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     how to install a web sever on ubuntu linux?     
  </Question>
  <Answer>
     Apache is the most commonly used Web server on Linux systems. Web servers are used to 
     serve Web pages requested by client computers?   

     To install one:
     1: sudo apt install apache2
  </Answer>
</QA>
<QA ID="336" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     How to install strace on different linux distribution?      
  </Question>
  <Answer>
    $ sudo apt install strace    #Debian/Ubuntu
    $ yum install strace         #RHEL/CentOS
    $ dnf install strace         #Fedora 22+
  </Answer>
</QA>
<QA ID="337" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     What is the top 10 usage of strace?     
  </Question>
  <Answer>
    1: Trace System Calls: strace df -h
    2: Trace Process PID: sudo strace -p 1234
    3: Get Summary of a Process: Using the -c flag, you can generate a report of total time, 
       calls, and errors for each system call:              sudo strace -c -p 1234
    4: Print instruction Pointer for each system call (-i): sudo strace -i df -h
    5: Show time stamp for each trace line(-t):             sudo strace -t df -h
    6: Show time used for each system call (-T):            sudo strace -T df -h
    7: Trace Only Specific System Calls(-e):    sudo strace -e trace=write df -h
    8: Trace System calls on certain condition: sudo strace -q -e trace=process df -h
                                                sudo strace -q -e trace=file    df -h
                                                sudo strace -q -e trace=memory  df -h 
                                                sudo strace -e trace=network df -h
                                                sudo strace -e trace=signal  df -h
    9: Redirect trace output to file(-o):       sudo strace -o df_debug.txt df -h
   10: Show some debugging output (-d):         strace -d df -h
  </Answer>
</QA>
<QA ID="338" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is Tag Dispatching?     
  </Question>
  <Answer>
    Tag dispatching is a way of using function overloading to dispatch based on properties of a type.
  </Answer>
</QA>
<QA ID="339" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     what is the /var Directory for ?     
  </Question>
  <Answer>
    /var is a standard subdirectory of the root directory that contains files to which the system writes 
    data during the course of its operation.
 
    /var is specific for each computer; that is, it is not shared over a network with other computers.

    /var/cache (contains cached data from application programs), 
    /var/games (contains variable data relating to games in /usr), 
    /var/lib   (contains dynamic data libraries and files), 
    /var/lock  (contains lock files created by programs to indicate that they are using a particular file or device), 
    /var/log   (contains log files), 
    /var/run   (contains PIDs and other system information that is valid until the system is booted again)
    /var/spool (contains mail, news and printer queues).
    /var/www/html contains the web server dir ?
   
  </Answer>
</QA>
<QA ID="340" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is SOAP?     
  </Question>
  <Answer>
    SOAP (Simple Object Access Protocol) is a messaging protocol specification for exchanging structured information 
    in the implementation of web services in computer networks. Its purpose is to induce extensibility, neutrality 
    and independence. It uses XML Information Set for its message format, and relies on application layer protocols, 
    most often Hypertext Transfer Protocol (HTTP) or Simple Mail Transfer Protocol (SMTP), for message negotiation 
    and transmission.

    SOAP allows processes running on disparate operating systems (such as Windows and Linux) to communicate using 
    Extensible Markup Language (XML). Since Web protocols like HTTP are installed and running on all operating systems, 
    SOAP allows clients to invoke web services and receive responses independent of language and platforms.

    - SOAP is a communication protocol designed to communicate via Internet.
    - SOAP can extend HTTP for XML messaging.
    - SOAP provides data transport for Web services.
    - SOAP can exchange complete documents or call a remote procedure.
    - SOAP can be used for broadcasting a message.
    - SOAP is platform- and language-independent.
    - SOAP is the XML way of defining what information is sent and how.
    - SOAP enables client applications to easily connect to remote services and invoke remote methods.
  </Answer>
</QA>
<QA ID="341" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     When you are trying to delete empty lines using sed '/^$/d' and it doesn't work, how to proceed ?     
  </Question>
  <Answer>
    Use tool dos2unix to change to unix format before using the sed '/^$/d' !
    you can use tool XXD &lt;file&gt; to exam the file in binary format.
  </Answer>
</QA>
<QA ID="342" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What are the stages of the waterfall model?
  </Question>
  <Answer>
     It is also referred to as a linear-sequential life cycle model. 
     It is very simple to understand and use. In a waterfall model, 
     each phase must be completed before the next phase can begin 
     and there is no overlapping in the phases. The Waterfall model 
     is the earliest SDLC approach that was used for software development.
  </Answer>
</QA>
<QA ID="343" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What are 5 most popular memory debuggers for Linux ?
  </Question>
  <Answer>
     1: Dmalloc
     2: Electric Fence
     3: Memorycheck
     4: Memwatch
     5: Mtrace
  </Answer>
</QA>
<QA ID="344" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Agile Methodology
  </Question>
  <Answer>
     The Agile Method is a particular approach to project management that is utilized in
     software development. This method assists teams in responding to the unpredictability of
     constructing software. It uses incremental, iterative work sequences that are commonly
     known as sprints.
     
     A sprint is a period of time allocated for a particular phase of a project. Sprints are
     considered to be complete when the time period expires. There may be disagreements among
     the members of the team as to whether or not the development is satisfactory; however,
     there will be no more work on that particular phase of the project. The remaining phases
     of the project will continue to develop within their respective time frames.
     
     The general principles of the Agile Method
     - Satisfy the client and continually develop software.
     - Changing requirements are embraced for the client's competitive advantage.
     - Concentrate on delivering working software frequently. Delivery preference will be
       placed on the shortest possible time span.
     - Developers and business people must work together throughout the entire project.
     - Projects must be based on people who are motivated. Give them the proper environment
       and the support that they need. They should be trusted to get their jobs done.
     - Face-to-face communication is the best way to transfer information to and from a team.
     - Working software is the primary measurement of progress.
     - Agile processes will promote development that is sustainable. Sponsors, developers, and
       users should be able to maintain an indefinite, constant pace.
     - Constant attention to technical excellence and good design will enhance agility.
     - Simplicity is considered to be the art of maximizing the work that is not done, and it
       is essential.
     - Self-organized teams usually create the best designs.
     - At regular intervals, the team will reflect on how to become more effective, and they
       will tune and adjust their behavior accordingly
  </Answer>
</QA>
<QA ID="345" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What the command git bisect can do ?
  </Question>
  <Answer>
     git bisect - Use binary search to find the commit that introduced a bug.

        This command uses a binary search algorithm to find which commit in your project's
     history introduced a bug. You use it by first telling it a "bad" commit that is known to
     contain the bug, and a "good" commit that is known to be before the bug was introduced.
     Then git bisect picks a commit between those two endpoints and asks you whether the
     selected commit is "good" or "bad". It continues narrowing down the range until it finds
     the exact commit that introduced the change.

     Example: 
     $ git bisect start
     $ git bisect bad                 # Current version is bad
     $ git bisect good v2.6.13-rc2
  </Answer>
</QA>
<QA ID="346" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is NFS ?
  </Question>
  <Answer>
     NSF stands for Network File System, it is a distributed file system protocol originally 
     developed by Sun Microsystems in 1984, allowing a user on a client computer to access 
     files over a computer network much like local storage is accessed.

       The Network File System (NFS) is a client/server application that lets a computer user
     view and optionally store and update files on a remote computer as though they were on
     the user's own computer. The NFS protocol is one of several distributed file system
     standards for network-attached storage (NAS).
          
       NFS allows the user or system administrator to mount (designate as accessible) all or a
     portion of a file system on a server. The portion of the file system that is mounted can
     be accessed by clients with whatever privileges are assigned to each file (read-only or
     read-write). NFS uses Remote Procedure Calls (RPC) to route requests between clients and
     servers.
  </Answer>
</QA>
<QA ID="347" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     what does this line do ?  grep yali /etc/passwd   | cut -f 1 -d :
  </Question>
  <Answer>
     print user name zhuyali

     example:
     $(/home/zhuyali) grep yali /etc/passwd
     zhuyali:x:1000:1000:Ubuntu:/home/zhuyali:/bin/bash

     $(/home/zhuyali) grep yali /etc/passwd   | cut -f 2  -d :
     x
     $(/home/zhuyali) grep yali /etc/passwd   | cut -f 1  -d :
     zhuyali
     
     cut --help:
          -f: select only these fileds, also print any lines that contains no delimiter 
               character, unless the -s option is  specified
          -d: use specified delimiter instead of TAB for field delimiter
          -s: do not print lines not containing delimiters
  </Answer>
</QA>
<QA ID="348" type="OneAnswer" category="LINUX" countdown="0" resetto="0" >
  <Question>
     what does the first character mean in directory listing using ls -l "
  </Question>
  <Answer>
     (/dev) ls k* -al
     crw-r--r-- 1 root root 1, 11 Jul 10 00:12 kmsg

     what does the leading c mean above ?

     Answer: The first character can be any of these:

     d = directory
     - = regular file
     l = symbolic link
     s = Unix domain socket
     p = named pipe
     c = character device file
     b = block device file
  </Answer>
</QA>
<QA ID="349" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is dmesg and what is /proc/kmsg ?
  </Question>
  <Answer>
     Output of /proc/kmsg can be directed to a file when collecting large amount of logs so
     that no logs are lost

     dmesg is circular buffer and previous logs get overwritten once buffer is full
  </Answer>
</QA>
<QA ID="350" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is printk ?
  </Question>
  <Answer>
     printk is a function that prints messages and is used in the C Programming Language
     exclusively for the Linux Kernel. It accepts a string parameter called the format string,
     which specifies a method for rendering an arbitrary number of varied data type
     parameter(s) into a string. The string is then printed to the kernel log.

     It provides a printf-like abstraction and its parsing of the format string and arguments
     behave exactly the same way. It acts as a debugging tool for kernel programmers who need
     this function for logging messages from the kernel.

     printk has an optional prefix string: Loglevel.

     Loglevel specifies the type of message being sent to the kernel message log. The syntax
     with loglevel is:
     printk(KERN_DEBUG "Debug message shown!\n");
     Different Loglevels, along with their numerical values, are shown here:

     0  KERN_EMERG      Emergency condition, system is probably dead
     1  KERN_ALERT      Some problem has occurred, immediate attention is needed
     2  KERN_CRIT       A critical condition
     3  KERN_ERR        An error has occurred
     4  KERN_WARNING    A warning   &lt;================ default level
     5  KERN_NOTICE     Normal message to take note of
     6  KERN_INFO       Some information
     7  KERN_DEBUG      Debug information related to the program
     When a log level is not specified, the default log level is KERN_WARNING, unless a
     different default has been set in the kernel itself.

     Loglevels are defined in &lt;linux/kern_levels.h>. Which log levels are printed is
     configured in the /proc/sys/kernel/printk sysctl file (format: console level, default
     message level, minimum console level, default console level)
  </Answer>
</QA>
<QA ID="351" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     what is /dev/kmsg ?
  </Question>
  <Answer>
     (/dev) ls k* -al
     crw-r--r-- 1 root root 1, 11 Jul 10 00:12 kmsg

     kmsg here is a char device

     The /dev/kmsg character device node provides userspace access
     to the kernel's printk buffer.

     Every write() to the opened device node places a log entry in
     the kernel's printk buffer.

  </Answer>
</QA>
<QA ID="352" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     How to see kernel messages ?
  </Question>
  <Answer>
     dmesg
     dmesg | grep -i memory
     dmesg | grep -i file
  </Answer>
</QA>
<QA ID="353" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Why do I still get "permission denied" using sudo as following ? 
    
     sudo echo "Writing critical printk messages from userspace" > /dev/kmsg
  </Question>
  <Answer>
     sudo doesn't work because echo is not a command, it's a shell builtin. 
     The right way to do that is:

       echo "blah" | sudo tee /dev/kmsg

     tee is a command that copies stdin to a file and stdout. It's called tee 
     because it's like a T-shaped pipe in a pipeline.

     Example:

     $ (/home/zhuyali) echo "Yali test" > /dev/kmsg
     -bash: /dev/kmsg: Permission denied
     $ (/home/zhuyali) sudo echo "Yali test" > /dev/kmsg
     -bash: /dev/kmsg: Permission denied
     $ (/home/zhuyali)  echo "Yali test" | sudo tee /dev/kmsg
      Yali test
     $ (/home/zhuyali) dmesg | grep Yali
     [192063.406398] Yali test
     $ (/home/zhuyali)
  </Answer>
</QA>
<QA ID="354" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     mmmmmmmmmmmmmmmmmmmmmm?     
  </Question>
  <Answer>
     xxxxxxxxxxxxxxxxx
  </Answer>
</QA>
<QA ID="355" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     mmmmmmmmmmmmmmmmmmmmmm?     
  </Question>
  <Answer>
     xxxxxxxxxxxxxxxxx
  </Answer>
</QA>
<QA ID="356" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     mmmmmmmmmmmmmmmmmmmmmm?     
  </Question>
  <Answer>
     xxxxxxxxxxxxxxxxx
  </Answer>
</QA>
<QA ID="357" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     mmmmmmmmmmmmmmmmmmmmmm?     
  </Question>
  <Answer>
     xxxxxxxxxxxxxxxxx
  </Answer>
</QA>
<QA ID="358" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     mmmmmmmmmmmmmmmmmmmmmm?     
  </Question>
  <Answer>
     xxxxxxxxxxxxxxxxx
  </Answer>
</QA>
<QA ID="359" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     mmmmmmmmmmmmmmmmmmmmmm?     
  </Question>
  <Answer>
     xxxxxxxxxxxxxxxxx
  </Answer>
</QA>
<QA ID="360" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     mmmmmmmmmmmmmmmmmmmmmm?     
  </Question>
  <Answer>
     xxxxxxxxxxxxxxxxx
  </Answer>
</QA>
<QA ID="361" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     mmmmmmmmmmmmmmmmmmmmmm?     
  </Question>
  <Answer>
     xxxxxxxxxxxxxxxxx
  </Answer>
</QA>

</QuestionsAndAnswers>