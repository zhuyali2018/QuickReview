<?xml version="1.0"?>
<!DOCTYPE QR SYSTEM "QuickReview.dtd">

<QuestionsAndAnswers>

<QA ID="1" type="OneAnswer" category="CPP" countdown="0" resetto="0" >

  <Question>
        How can I handle a constructor that fails ?
  </Question>

  <Answer>
     throw an exception. Constructors don't have a return type, so it's not possible to use return codes. The best way to signal constructor failure is therefore to throw an exception.
  </Answer>
</QA>


<QA ID="2" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is difference between process and thread ?
  </Question>
  <Answer>
      A process provides the resources needed to execute a program. A process has:
        - a virtual address space, 
        - executable code, 
        - open handles to system objects, 
        - a security context,          - process identifier, 
        - environment variables, 
        - at least one thread of execution ( Each process is started with a single thread, often called the primary thread, but can create additional threads from any of its threads.)

      A thread is the entity within a process that can be scheduled for execution. 
        - All threads of a process share its:
           - virtual address space and 
           - system resources. 
        - each thread maintains 
           - exception handlers, 
           - a scheduling priority, 
           - thread local storage, 
           - a unique thread identifier, 
           - a set of structures the system use to save the thread context until it is scheduled. 
           - each thread context includes :
              - the thread's set of machine registers, 
              - the kernel stack, 
              - a thread environment block, 
              - a user stack in the address space of the thread's process. 
              - a security context, which can be used for impersonating clients.
  </Answer>
</QA>
<QA ID="3" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      Difference between Lock and control variable ?
  </Question>
  <Answer>
        ??
  </Answer>
</QA>
<QA ID="4" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      Difference between mutex and semorephone ?
  </Question>
  <Answer>
      A mutex can be owned by only one thread at a time, enabling threads to coordinate mutually exclusive access to a shared resource.
      A semaphore maintains a count between zero and some maximum value, limiting the number of threads that are simultaneously accessing a shared resource.
  </Answer>
</QA>
<QA ID="5" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is Unique pointer and what is the diffrence between unique pointer and shared pointer?
  </Question>
  <Answer>
      Unique pointer and Shared pointer are all smart pointers. Unique pointer means an object can only be pointered by one pointer
      shared poitners keeps a count on number of pointers to an object and when the count drops to 0, the object is destroied !
  </Answer>
</QA>
<QA ID="6" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is weak poitner?
  </Question>
  <Answer>
      Weak pointer is a kind of pointer that does not own the object, does not affect the pointer count!
  </Answer>
</QA>
<QA ID="7" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is vector?
  </Question>
  <Answer>
    A vector is a dynamic array that can only grow in one direction, and is contiguously allocated in memory.

   vector pros and cons:
   - fast insert/remove at the end: O(1)
   - slow insert/remove at the begining and middle: O(n)
   - slow search (linear time): O(n)
   - random access
  </Answer>
</QA>

<QA ID="8" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is deque ?
  </Question>
  <Answer>
      A deque is a dynamic array that can grow in both directions, and is contiguously allocated in memory.
  </Answer>
</QA>

<QA ID="9" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is array and what is its pros and cons ?
  </Question>
  <Answer>
      array is fixed in size! and different size makes them different types.
  </Answer>
</QA>
<QA ID="10" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is the difference between list and forward list ?
  </Question>
  <Answer>
      list is a doubly-linked list. Forward list is a singly-linked list
  </Answer>
</QA>
<QA ID="11" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is weak poitner?
  </Question>
  <Answer>
      Weak pointer is a kind of pointer that does not own the object, does not affect the pointer count!
  </Answer>
</QA>
<QA ID="12" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What are STL Containers
  </Question>
  <Answer>
   STL Containers can be divieded into 3 categories:
   1) Sequence Containers (Array and linked list)
       - vector
       - deque
       - list
       - forward list
       - array
   2) Associative Containers (binary tree)
       - set, multiset,
       - map, multimap
   3) Unordered Containers (hash table)
       - Unordered set/multiset;
       - Unordered map/multimap

   its headers to include: 
        - &lt;vector&gt;
        - &lt;deque&gt;
        - &lt;list&gt;
        - &lt;set&gt;
        - &lt;map&gt;
        - &lt;unordered_set&gt;
        - &lt;unordered_map&gt;

   other STL includes:
        - &lt;iterator&gt;
        - &lt;algorithm&gt;
        - &lt;numeric&gt;     
        - &lt;functional&gt;  //for functors

   methods shared across all containers:
   - empty()   //check for empty
   - size()
   - clear()   //remove all elements
   - swap(T)   //swap all elements
  </Answer>
</QA>
<QA ID="13" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is associate containers ?
  </Question>
  <Answer>
      Associate containers refer to map/multimap and set/multiset.
      Associate means keys are associated with values
      For set/map, the keys can be considered the same as values
      - They are always sorted, so no push_front(), push_back() methods
      - They are implemented as binary tree.
      - They are fast in search
      - They are slow in traversing
      - No Random acces, no [] operator
      - Elements (keys) can't be modified
  </Answer>
</QA>
<QA ID="14" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      show some set snippets:
  </Question>
  <Answer>

  snippet:

    set&lt;int&gt; myset;
    myset.insert(3);
    myset.insert(1);
    myset.insert(7);         //myset: {1,3,7}

    set&lt;int&gt;::iterator it;
    it=myset.find(7);       //fast, sequence containers do not have find() memeber function
                            //fast O(log(n))   &lt;=====outstanding feature
    pair&lt;set&lt;int&gt;::iterator, bool&gt; ret;
    ret=myset.insert(3);    //no new element inserted, because no duplicates allowed
    if(ret.second==false)   //return a pair of values: ret.first, ret.second
      it=ret.first;         //"it" now points to element 3
     
    myset.insert(it,9);     //hint where it is pointing to, {1,3,7,9}
    myset.erase(it);        //myset: {1,7,9}
    myset.erase(7);         //myset: {1,9}
   
  </Answer>
</QA>
<QA ID="15" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      what is difference between set and muti set ?
  </Question>
  <Answer>
      Difference is that multi set allows duplcates while set does not allow duplicates
      Difference between map and multimap is multimap allows duplicate keys
  </Answer>
</QA>
<QA ID="16" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is the difference between set/multiset and map/multimap ?
  </Question>
  <Answer>
      Map/multimap is just a key-value paired version of set/multiset.
  </Answer>
</QA>
<QA ID="17" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What about unordered containers ? what are unordered containers and what are their pros and cons
  </Question>
  <Answer>
      Unordered set/multiset, map/multimap are unordered containers
      they are implemented as hash tables 
      has following features:
        -fast search O(1)
        -fast insert O(1)
        -element value can't be changed for unordered set/multiset
        -element key can't be change for unordered map/multimap

      snippet:
        unordered_set&lt;string&gt; = { "red", "green", "blue" };
        unordered_set&lt;string&gt;::const_iterator itr =  myset.find("green");  //fast, O(1)
        if(itr != myset.end())   //need to check if found
          cout &lt;&lt; *itr &lt;&lt; endl;
        myset.insert("yellow");   // O(1), fast

        vector&lt;string&gt; vec={"purple","pink"};    //an vector to be inserted into myset
        myset.insert(vec.begin(), vec.end());    //insert a vector into a set 

        //Hash table APIs: load_factor(),bucket(),bucket_count()
        cout &lt;&lt; "load_factor="&lt;&lt; myset.load_factor() &lt;&lt; endl;
        string x = "red";
        cout &lt;&lt; x &lt;&lt; " is in buket #" &lt;&lt; myset.bucket(x) &lt;&lt; endl;
        cout &lt;&lt; "Total bucket #=" &lt;&lt; myset.bucket_count() &lt;&lt; endl;

  </Answer>
</QA>
<QA ID="18" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is Associate Array?
  </Question>
  <Answer>
      Associate Array is map and unordered map. They are Associate Containers with [] operators.
      
      Following snippet shows its usages:
       
      unordered_map&lt;char, string&gt; day={{'S',"Sunday"},{'M',"Monday"}};

      cout &lt;&lt; day['S']    &lt;&lt; endl;    //No  range check
      cout &lt;&lt; day.at('S') &lt;&lt; endl;    //Has range check

      vector&lt;int&gt; vec={1,2,3};
      vec[5]=5;                             // compile Error: out of range

      day['W'] = "Wednesday";               //OK, inserting {'W',"Wednesday'}
      day.insert(make_pair('F',"FRIDAY"));  //inserting, same as above

      day.insert(make_pair('M',"MONDAY));   //Already exist for M, failed
      day['M'] = "MONDAY";                  //Succeeded modifying: [] operator has write access

      //Effect of [] operator's write access:
      void foo (const unordered_map&lt;char, string&gt; &#38; m ) { //param m is const reference
         m['S'] = "SUNDAY";                  //compile error, write access
         cout &lt;&lt; m['S'] &lt;&lt; endl;            //compile error too for print access, which is write access writing this way
         auto itr = m.find('S');
         if(itr !=m.end())
           cout &lt;&lt; itr-&gt;second &lt;&lt;endl;       //compile OK, no write access !
      }

      foo(day);

      //so, use map or unordered map ? here are the factors to consider:
      // Associate array: map and unordered_map only:
      1 search O(1): unordered_map =&gt; may degrade to O(n)
          O(log(n)): map =&gt; garanteed O(log(n)) search time
      2 Can't use multimap and unordered_multimap:
          they do not have [] operator, so can't be used as an array
  </Answer>
</QA>

<QA ID="19" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is Container Adapter ?
  </Question>
  <Answer>
      Container Adapter provide restricted interface to underlying containers to meet special needs
      they are implemetned with fundamental container classes. There are 3:
      1. queue: FIFO:   push(), pop(), front(), back()
      2. stack: LIFO:   push(), Pop(), top()
      3. priority queue:push(), pop(), top(). First item always has the greatest priority
                 
      
  </Answer>
</QA>

<QA ID="20" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What are the 5 kinds of the iterators ?
  </Question>
  <Answer>
      1: Ramdom access iterators: vector, deque, array
      2: Bidirectional Iterators: list, set/multiset, map/multimap
      3: Forward Iterators: forward_list
      4: Input Iterator: int x = *itr; //can only move forward
      5: Output Iterator: *itr=100;    //can only move forward 

      Every container has a iterator and a const_iterator (Snippet):
      set&lt;int&gt;::iterator itr;           //RW access to container elements
      set&lt;int&gt;::const_interator citr;   //readonly access to container elements

      set&lt;int&gt; myset = {1,4,5,2,9};
      for(citr=myset.begin();citr!=myset.end();++citr){
        cout &lt;&lt; *citr &lt;&lt; endl;
        //*citr=3;   //error, citr has readonly access
      }

      for_each(myset.cbegin();myset.cend(),myfunction);   //C++11

      //iterator functions:
      advance(itr,5);          //Move itr forward by 5: itr += 5;
      distance(itr1,itr2);     //measure the distance between itr1 and itr2
  </Answer>
</QA>

<QA ID="21" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
    What is Iterator Adapter ?
  </Question>
  <Answer>
    Iterator adapters are predefined iterators, they are more powerful:

      1. Insert iterator (back_insert_iterator,front_insert_iterator)
      2. Stream iterator
      3. Reverse iterator
      4. Move iterator (c++11)

    Snippet:
      1. Insert iterator:

      vector&lt;int&gt; vec1 = {4,5};
      vector&lt;int&gt; vec2 = {13,14,16,18};
      vector&lt;int&gt;::iterator it = find(vec2.begin(),vec2.end(),16);
      insert_iterator&lt;vector&lt;int&gt;&gt; i_itr(vec2,it);
      copy(vec1.begin(),vec1,end(),i_itr);   //vec2: {12,14,4,5,16,18}
      // Other insert iterators: back-insert_iterator, front_insert_iterator

      2. Stream iterator: iterat through the data to and from a string:
         vector&lt;string&gt; vec4;
         copy(istream_iterator&lt;string&gt;(cin), istream_iterator&lt;string&gt;(),     //copy source range
             back_inserter(vec4));                                           //copy dest, insert everything into vec4 from input stream
         copy(vec4.begin(),vec4.end(),ostream_iterator&lt;string&gt;(cout, " "));  //dump vec4 to cout with " " as delimiter       
         //merge the 2 copy operation above into one:
         copy(istream_iterator&lt;string&gt;(cin),istream_iterator&lt;string&gt;(),
              ostream_iterator&lt;string&gt;(cout," "));  
            
      3. Reverse iterator: travese container in reversed order
         vector&lt;int&gt; vec = {4,5,6,7};
         reversee_iterator&lt;vector&lt;int&gt;::iterator&gt; ritr;
         for(ritr = vec.rbegin(); ritr!=vec.rend();ritr++)
             cout &lt;&lt; *ritr &lt;&lt; endl;     //prints: 7,6,5,4

      4. Move iterator (c++11): ??

  </Answer>
</QA>

<QA ID="22" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      Why is pre increment (++i) is faster than post increment (i++) ?
  </Question>
  <Answer>
      pre increment is faster because post-increment i++ needs to keep old value before increasing its own value,
      so it needs to create a temporary variable to hold the old value.
  </Answer>
</QA>

<QA ID="23" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Please give some examples of algorithms function usage
  </Question>
  <Answer>
      //algorithms - mostly loops

      vector&lt;int&gt; vec = {4,2,5,1,3,9};
      vector&lt;int&gt;::iterator itr = min_element(vec.begin(),vec.end()); //itr =&gt;1

      //Note 1: Algorithm always process range in a half-open way: [begin,end)
      sort(vec.begin(),itr);   //vec:{2,4,5,1,3,9}
      reverse(itr,vec.end());  //vec: {2,4,5,9,3,1}    //itr=&gt;9

      // Note 2: vec2 needs to have at least space for 3 elements:
      vector&lt;int&gt; vec2(3);
      copy(itr,vec.end(),       //Source
            vec2.begin());      //Destination

      //Note 3:  (back_inserter is inserting at the end of a container, I guess)
      vector&lt;int&gt; vec3;
      copy(itr,vec.end(),back_inserter(vec3));  //insert, not overwrite
                   //back_insert_iterator is not efficient, slow, insert 1 at a time
      vec3.insert(vec3.end(),itr,vec.end());    //efficient, fast, insert all at a time

      //Note 4: algorithms with functions
      bool isOdd(int i){
           return i%2;
      }

      int main() {
         vector&lt;int&gt; vec ={2,4,5,9,2}
         vector&lt;int&gt;::iterator itr = find_if(vec.begin(),vec.end(),isOdd);  //itr =&gt;5
      }

      //Note 5: Algorithm with native c++ array
      int arr[4] = {6,3,7,4};
      sort(arr,arr+4);

  </Answer>
</QA>

<QA ID="24" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What are all the implicit member functions of a class? 
     Or what are all the functions which compiler implements for us if we don't define one?
  </Question>
  <Answer>
      1. default ctor
      2. copy ctor
      3. assignment operator
      4. default destructor
      5. address operator
  </Answer>
</QA>

<QA ID="25" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      what is the difference between new and malloc() in terms of memory allocation ?
  </Question>
  <Answer>
      In C++, if the runtime system cannot allocate sizeof(Fred) bytes of memory during p= new Fred(), 
      a std::bad_alloc exception will be thrown. 

      With malloc(), it will return NULL if allocation fails
  </Answer>
</QA>

<QA ID="26" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      Do I need to check for NULL before delete p?
  </Question>
  <Answer>
      No !
  </Answer>
</QA>


<QA ID="27" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      Name 6 operators that cannot be overloaded ?
  </Question>
  <Answer>
      (1) sizeof 
      (2) dot : .  
      (3) star: * 
      (4) arrow: -> 
      (5) Scope resolution operator: :: 
      (6) ?:
  </Answer>
</QA>

<QA ID="28" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      How many ways are there to initialize an int with a constant?
  </Question>
  <Answer>
      (1) int foo = 123;  
      (2) int bar(123);
  </Answer>
</QA>

<QA ID="29" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What are the debugging methods or steps you use ?
  </Question>
  <Answer>
      1. GDB, DBG, Forte, Visual Studio.     (Forte for java ?)
      2. Analyzing the Core dump.
      3. Using tusc to trace the last system call before crash. (HP ?)
      4. Putting Debug statements in the program source code.
  </Answer>
</QA>

<QA ID="30" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
    Why do C++ compilers need name mangling?
  </Question>
  <Answer>
        Name mangling is the rule according to which C++ compiler changes function's name
    into function signature before passing that function to a linker. This is how a linker 
    differentiates between different functions with the same name.
  </Answer>
</QA>

<QA ID="31" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What are C++ storage classes?
  </Question>
  <Answer>
      There are 4 storage classes: 
                       Lifetime:
        1. auto        Function Block       
        2. register    Function Block       
        3. static      Whole Program
        3. extern      Whole Program

         auto: the default. Variables are automatically created and initialized when they 
               are defined and are destroyed at the end of the block containing their 
               definition. They are not visible outside that block.
         (another auto for type of class) auto i = 1; //i is auto declared as integer, c++11 ?)
         register: a type of auto variable. a suggestion to the compiler to use a 
               CPU register for performance.
         static: a variable that is known only in the function that contains its 
               definition but is never destroyed and retains its value between calls 
               to that function. It exists from the time the program begins execution.
         extern: a static variable whose definition and placement is not determined until
               all object and library modules are combined (linked) to form the executable 
               code file. It can be visible outside the file where it is defined.

  </Answer>
</QA>

<QA ID="32" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is an Iterator class?
  </Question>
  <Answer>
      A class that is used to traverse through the objects maintained by a container class.
  </Answer>
</QA>
<QA ID="33" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      How can I open a stream in binary mode?
  </Question>
  <Answer>
      Use std::ios::binary.
  </Answer>
</QA>
<QA ID="34" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What constant defined in &lt;climits&gt; header returns the number of bits in a char?

      a) CHAR_SIZE    
      b) SIZE_CHAR    
      c) BIT_CHAR   
      d) CHAR_BIT
  </Question>
  <Answer>
      d, CHAR_BIT
  </Answer>
</QA>
<QA ID="35" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      The size_t integer type in C++ is?
  </Question>
  <Answer>
      Unsigned integer of at least 16 bits.

          The size_t type is used to represent the size of an object. 
      Hence, it&#39;s always unsigned. According to the language specification, 
      it is at least 16 bits.
  </Answer>
</QA>
<QA ID="36" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What are 3 float types? if extended precision is required, which one shoule be used ?
  </Question>
  <Answer>
      3 types are: float, double and long double. 
      Should use long double for extended precision.
  </Answer>
</QA>
<QA ID="37" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      If a decimal precision setting is required, what function to use and what header to include?
  </Question>
  <Answer>
      Use setprecision(int p) function and include header &lt;iomanip&gt; for input/output manipulation
  </Answer>
</QA>
<QA ID="38" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      In which type does the enumerators are stored by the compiler?

      a) string
      b) integer
      c) float
      d) none of the mentioned

  </Question>
  <Answer>
      b
  </Answer>
</QA>
<QA ID="39" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is the default calling convention for a compiler in c++?

      a) __cdecl
      b) __stdcall
      c) __pascal
      d) __fastcall	
  </Question>
  <Answer>
      a
  </Answer>
</QA>
<QA ID="40" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      Function pointer example
  </Question>
  <Answer>
      #include &lt;iostream&gt;
      using namespace std;

      int add(int first, int second){
         return first + second + 15;
      }

      int operation(int first, int second, int(*functocall)(int, int)){
         return (*functocall)(first, second);
      }

      int main(){
        int  a;
        int(*plus)(int, int) = add;
        a = operation(15, 10, plus);
        cout &lt;&lt; a;
        return 0;
      }
  </Answer>
</QA>

<QA ID="41" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is keyword volatile and how to use it ?
  </Question>
  <Answer>
        C's volatile keyword is a qualifier that is applied to a variable when it is declared. 
      It tells the compiler that the value of the variable may change at any time--without 
      any action being taken by the code the compiler finds nearby. 

      volatile is used to prevent changes from compiler optimization; 

      2 ways to declare it:

      volatile uint16_t x; 
      uint16_t volatile y;

      if you really must have a volatile pointer to a volatile variable, you'd write:

      uint16_t volatile * volatile p_y;

      It is used for things like memory-mapped I/O registers

      Proper Use of C's volatile Keyword:

        A variable should be declared volatile whenever its value could change unexpectedly. 
      In practice, only three types of variables could change:

      1. Memory-mapped peripheral registers
      2. Global variables modified by an interrupt service routine
      3. Global variables accessed by multiple tasks within a multi-threaded application

          Embedded systems contain real hardware, usually with sophisticated peripherals. 
      These peripherals contain registers whose values may change asynchronously to the 
      program flow. As a very simple example, consider an 8-bit status register that is 
      memory mapped at address 0x1234. It is required that you poll the status register 
      until it becomes non-zero. The naive and incorrect implementation is as follows:

      uint8_t * p_reg = (uint8_t *) 0x1234;

      // Wait for register to read non-zero 
      do { ... } while (0 == *p_reg)

      This code will almost certainly fail as soon as you turn compiler optimization on.
  </Answer>
</QA>

<QA ID="42" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      By default members of a structure are: 
       A - private
       B - protected
       C - public
       D - Access specifiers not applicable for structures
  </Question>
  <Answer>
      C.  default members of a class is private, structure is public 
  </Answer>
</QA>

<QA ID="43" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      Can a constructor be virtual
  </Question>
  <Answer>
      No! (but why ? explain!)
  </Answer>
</QA>

<QA ID="44" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      What is the output of the following program ?
       
      #include &lt;iostream&gt;
      using namespace std;

      class Base{
      public:
          void f(){ cout &lt;&lt; "base\n"; }
      };

      class Derived:public Base {
      public:
         void f() { cout &lt;&lt; "Derived\n";}
      };

      main(){
         Derived obj;
         obj.Base::f();
      }
       
      A - Base
      B - Derived
      C - Compile error
      D - None of the above    
  </Question>
     
  <Answer>
      A
  </Answer>
</QA>

<QA ID="45" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     #include &lt;iostream&gt;

     using namespace std;
     class abc{
        void f();
        void g();
        int x;
     };

     main(){
        cout &lt;&lt; sizeof(abc)&lt;&lt;endl;
     }

     A: 12
     B: 4
     C: 8
     D: Compile error
  </Question>
  <Answer>
      B.  it is the size of all variables, function declaration does not take any space
  </Answer>
</QA>

<QA ID="46" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     In the following program, is f() overloaded ?
 
     void f(int x){}
     void f(signed x){}
     main() {}

  </Question>
  <Answer>
      No. Because Plain int is the same as signed, and is the same as signed int too.
  </Answer>
</QA>
<QA ID="47" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      Choose the respective delete operator usage for the expression: ptr=new int[100];
 
      A: delete ptr;
      B: delete ptr[];
      C: delete [] ptr;
      D: []delete ptr;
  </Question>
  <Answer>
      C
  </Answer>
</QA>
<QA ID="48" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      An exception is 
    
      A: Runtime error
      B: Compile time error
      C: Logical error
      D: None of the above

  </Question>
  <Answer>
      D. Exception is not an error. 
         Difference between Exception and Error is: 
         Exceptions are those which can be handled at the run time whereas errors cannot be handled.
  </Answer>
</QA>
<QA ID="49" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      Pick up the valid declaration for overloading ++ in postfix form where T is the class name:
     
      A: T operator++();
      B: T operator++(int);
      C: T &#38; operator++();
      D: T &#38; operator++(int);
  </Question>
  <Answer>
      B. (but why ? look it up !)
  </Answer>
</QA>
<QA ID="50" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
      HAS-A relationship between the classes is shown through:

      A: Inheritance
      B: Container classes
      C: Polymorphism
      D: None of the above
  </Question>
  <Answer>
      Not A, It is B ! For example: A car is-a vehicle but A car has-a steering wheel
  </Answer>
</QA>
<QA ID="51" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is the output of the following program ?
 
     #include &lt;iostream&gt;

     using namespace std;
     void main(){
         char *s = "Fine";
         *s = 'N';
         cout &lt;&lt; s &lt;&lt; endl;
     }

     A: Fine
     B: Nine
     C: Compile error
     D: Runtime error

  </Question>
  <Answer>
      Not B, It is D: Runtime error: Exception thrown: write access violation

      if it was the line: char s[]="Fine"; 
      the answer would be B:

      This is because char * s="asdf"; is equivlant of const char *s ="asdf";

      A literal string in a C program is considered to be read-only and the 
      compiler/linker/loader may arrange for the memory of that string to be in 
      memory that is protected against writing.

  </Answer>
</QA>
<QA ID="52" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is the output of the following program ?
 
     #include &lt;iostream&gt;

     using namespace std;
     void main(){
         class student{
            int rno=10;
         } v;
         cout &lt;&lt; v.rno &lt;&lt; endl;
     }

     A: 10
     B: Garbage
     C: Compile error
     D: Runtime error

  </Question>
  <Answer>
      Not A, But C: Compile error. Because it is trying to access private member rno!
      class member is default to private. The test is testing for that knowledge !
  </Answer>
</QA>
<QA ID="53" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is the output of the following program ?

     #include &lt;iostream&gt;

     using namespace std;
     void main(){
         short unsigned int i=0;
         cout &lt;&lt; i-- ;
     }

     A: 0
     B: Compile error
     C: 65535
     D: 32767
  </Question>
  <Answer>
      Not C, it is A ! Because i-- is post increment, it will return 0 before 
      decreases and becomes 65535 (All bit set, since it is unsigned, it is 65535)
  </Answer>
</QA>

<QA ID="54" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Which operator is required to be overloaded as member function only ?

     A: _
     B: __
     C: ++ (postfix version)
     D: =
  </Question>
  <Answer>
      D. The "=" can not be overloaded as an independent function, like other operators do.
  </Answer>
</QA>

<QA ID="55" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is the output of the following program ?

     #include &lt;iostream&gt;

     using namespace std;
     class abc {
     public:
        int i;
        abc(int i) {
           i=i;
        }
     };
     void main(){
        abc m(5);
        cout &lt;&lt; m.i;
     }

     A: 5
     B: Garbage
     C: Error at the statement i=i;
     D: Compile error: i declared twice.

  </Question>
  <Answer>
      Not A, it is B ! Because i in constructor is defined in constructor as int, which
      hides the class variable i, so the 2 i's in the constructor are all i as the argument
      and the class variable i never get a change to be initialized and left with garbage!
  </Answer>
</QA>
<QA ID="56" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is the output of the following program ?

     #include &lt;iostream&gt;

     void main(){
        int r, x=2;
        float y=5;
        r=y%x;
        cout &lt;&lt; r;
     }

     A: 1
     B: 0
     C: 2
     D: Compile error

  </Question>
  <Answer>
      Not A, it is D ! Because y can't be float, it must be an integer to be meaningful.
  </Answer>
</QA>

<QA ID="57" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is a generic class ?

     A: Function template
     B: Class template
     C: inherited class
     D: None of the above
  </Question>
  <Answer>
     D. or the answer should be template class, not class template!
     Templates are the foundation of generic programming, which involves writing code in a way 
     that is independent of any particular type. A template is a blueprint or formula for 
     creating a generic class or a function.    
  </Answer>
</QA>

<QA ID="58" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Identify the c++compiler of Linux:

     A: cpp
     B: g++
     C: Borland
     D: vc++

  </Question>
  <Answer>
     B, not A !
  </Answer>
</QA>

<QA ID="59" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is the output of the following program ?

     #include &lt;iostream&gt;

     void main(){
        float t=2;
        switch(t){
        case 2: cout &lt;&lt "Hi";
        default:cout &lt;&lt; "Hello";
        }
     }

     A: Hi
     B: HiHello
     C: Hello
     D: Error
  </Question>
  <Answer>
     D.  Because the switch only takes integer !
  </Answer>
</QA>
<QA ID="60" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Which is the storage specifier used to modify the member variable even though
     the class object is a constant object ?

     A: auto
     B: register
     C: static
     D: mutable
  </Question>
  <Answer>
     D. Example Snippet: 
     class Foo {
     private:
        mutable bool done;
     public:
        void doSomething() const{    //&lt;==notice the keyword const
            done=true;               //&lt;==but can still modify mutable vars
        }
     };
  </Answer>
</QA>
<QA ID="61" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     That is the full form of RTTI ?

     A: Runtime type identification
     B: Runtime template identification
     C: Robust Template Type Inheritance
     D: None of the above

  </Question>
  <Answer>
     A
  </Answer>
</QA>

<QA ID="62" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is the output of the following program ?

     #include &lt;iostream&gt;
      
     using namespace std; 
     void main(){
        char s[]="C++";
        cout &lt;&lt; s &lt;&lt;" ";
        s++;
        cout &lt;&lt; s &lt;&lt;" ";
     }

     A: C++ C++
     B: C++ ++
     C: ++ ++
     D: Compile error
  </Question>
  <Answer>
     D, Not B: although in char * s and char s[], s can be both used as an pointer, 
     but s[] can not be used to do pointer math operations like post increment calculations!
  </Answer>
</QA>
<QA ID="63" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     With respective to streams, operator &gt;&gt; is called as

     A: Insertion operator
     B: Extraction operator
     C: Right shift operator
     D: Left shift operator
  </Question>
  <Answer>
     B. &gt;&gt; is extraction operator and &lt;&lt; is insertion operator!
  </Answer>
</QA>
<QA ID="64" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     Which feature of the OOP gives the concept of reusability ?

     A: Abstraction
     B: Encapsulation
     C: Inheritance
     D: None of the above
  </Question>
  <Answer>
     C
  </Answer>
</QA>

<QA ID="65" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is the output of the following program ?

     #include &lt;iostream&gt;
      
     using namespace std; 
     void main(){
        int *p= new int;
        delete p;
        delete p;
        cout &lt;&lt; "Done";
     }

     A: Done
     B: Compile error
     C: Runtime error
     D: None of the above
  </Question>
  <Answer>
     C !, but why ? do some research on this when you have time !!!
  </Answer>
</QA>
<QA ID="xx" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is a generic class ?
  </Question>
  <Answer>
     asf
  </Answer>
</QA>
<QA ID="xx" type="OneAnswer" category="CPP" countdown="0" resetto="0" >
  <Question>
     What is a generic class ?
  </Question>
  <Answer>
     asf
  </Answer>
</QA>

</QuestionsAndAnswers>